<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DONT FOLLOW THE WHITE RABBIT!</title>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: monospace;
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            touch-action: none;
        }
        #threeCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            touch-action: none;
        }
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 150px;
            pointer-events: none;
            z-index: 1000;
        }
        .control-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: auto;
            touch-action: manipulation;
            backdrop-filter: blur(8px);
            transition: all 0.15s;
            user-select: none;
        }
        .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.9);
            border-color: rgba(255, 255, 255, 0.6);
        }
        .left-controls {
            position: absolute;
            left: 30px;
            bottom: 20px;
            width: 150px;
            height: 150px;
        }
        .right-controls {
            position: absolute;
            right: 30px;
            bottom: 20px;
            width: 150px;
            height: 150px;
        }
        #btn-forward {
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }
        #btn-backward {
            left: 50%;
            bottom: 0;
            transform: translateX(-50%);
        }
        #btn-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        #btn-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }
        }
        @media (orientation: landscape) and (max-width: 920px) {
            .mobile-controls {
                display: block;
            }
            .left-controls {
                left: 20px;
                bottom: 10px;
            }
            .right-controls {
                right: 20px;
                bottom: 10px;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="threeCanvas"></canvas>
    <div class="mobile-controls">
        <div class="left-controls">
            <div class="control-btn" id="btn-forward">↑</div>
            <div class="control-btn" id="btn-backward">↓</div>
        </div>
        <div class="right-controls">
            <div class="control-btn" id="btn-left">←</div>
            <div class="control-btn" id="btn-right">→</div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', {
            alpha: false,
            antialias: false,
            depth: true,
            stencil: false,
            powerPreference: "high-performance",
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            failIfMajorPerformanceCaveat: false,
            desynchronized: true // DAHA HIZLI RENDER!
        }) || canvas.getContext('webgl', {
            alpha: false,
            antialias: false,
            powerPreference: "high-performance",
            desynchronized: true
        });
        if (!gl) {
            alert('WebGL not supported');
        }
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        const startTime = Date.now();
        const keys = {};
        let cameraYaw = 0;
        const cameraDistance = 20.0;
        const cameraHeight = 8.0;
        const rabbit = {
            position: { x: 0, y: 0, z: 5 },
            rotation: 0,
            moveSpeed: 14.0,
            verticalSpeed: 0,
            isJumping: false,
            jumpTime: 0,
            nextJumpIn: 120,
            jumpCooldown: 0
        };
        let isMoving = false;
        let cinematicMode = isMobile ? false : false;
        let cinematicTime = 0;
        if (isMobile) {
            console.log(' MOBILE DETECTED!');
            setTimeout(() => {
                const btnForward = document.getElementById('btn-forward');
                const btnBackward = document.getElementById('btn-backward');
                const btnLeft = document.getElementById('btn-left');
                const btnRight = document.getElementById('btn-right');
                console.log('Buttons:', btnForward, btnBackward, btnLeft, btnRight);
                if (btnForward) {
                    btnForward.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['w'] = true;
                        console.log('▲ FORWARD PRESSED');
                    }, { passive: false });
                    btnForward.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['w'] = false;
                        console.log('▲ FORWARD RELEASED');
                    }, { passive: false });
                    btnForward.addEventListener('touchcancel', (e) => { keys['w'] = false; });
                }
                if (btnBackward) {
                    btnBackward.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['s'] = true;
                        console.log('▼ BACKWARD PRESSED');
                    }, { passive: false });
                    btnBackward.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['s'] = false;
                        console.log('▼ BACKWARD RELEASED');
                    }, { passive: false });
                    btnBackward.addEventListener('touchcancel', (e) => { keys['s'] = false; });
                }
                if (btnLeft) {
                    btnLeft.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['a'] = true;
                        console.log('◀ LEFT PRESSED');
                    }, { passive: false });
                    btnLeft.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['a'] = false;
                        console.log('◀ LEFT RELEASED');
                    }, { passive: false });
                    btnLeft.addEventListener('touchcancel', (e) => { keys['a'] = false; });
                }
                if (btnRight) {
                    btnRight.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['d'] = true;
                        console.log('▶ RIGHT PRESSED');
                    }, { passive: false });
                    btnRight.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        keys['d'] = false;
                        console.log('▶ RIGHT RELEASED');
                    }, { passive: false });
                    btnRight.addEventListener('touchcancel', (e) => { keys['d'] = false; });
                }
            }, 100);
            document.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
        }
        let _0xb1c2 = false;
        let _0xd3e4 = 0;
        let _0xf5a6 = 0;
        let manualCameraAngle = 0;
        let manualCameraPitch = 0;
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' && !isMobile) {
                cinematicMode = !cinematicMode;
                if (cinematicMode) {
                    cinematicTime = 0;
                    console.log(' SİNEMATİK MOD AÇIK!');
                } else {
                    console.log(' MANUEL MOD AÇIK!');
                }
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        window.addEventListener('mousedown', (e) => {
            if (!isMobile) {
                _0xb1c2 = true;
                _0xd3e4 = e.clientX;
                _0xf5a6 = e.clientY;
                console.log('️ MOUSE DOWN - Kamera kontrolü aktif!');
            }
        });
        window.addEventListener('mouseup', () => {
            if (!isMobile) {
                _0xb1c2 = false;
                console.log('️ MOUSE UP');
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (_0xb1c2 && !isMobile) {
                const deltaX = e.clientX - _0xd3e4;
                const deltaY = e.clientY - _0xf5a6;
                manualCameraAngle -= deltaX * 0.005;
                manualCameraPitch += deltaY * 0.005;
                manualCameraPitch = Math.max(-1.5, Math.min(1.5, manualCameraPitch));
                _0xd3e4 = e.clientX;
                _0xf5a6 = e.clientY;
            }
        });
        const vertexShaderSource = atob("YXR0cmlidXRlIHZlYzIgcG9zaXRpb247CnZvaWQgbWFpbigpIHsKICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAuMCwgMS4wKTsKfQo=");
        const fragmentShaderSource = atob("cHJlY2lzaW9uIGhpZ2hwIGZsb2F0Owp1bmlmb3JtIHZlYzIgaVJlc29sdXRpb247CnVuaWZvcm0gZmxvYXQgaVRpbWU7CnVuaWZvcm0gYm9vbCBpc0RheVRpbWU7CnVuaWZvcm0gdmVjMyB1UmFiYml0UG9zOwp1bmlmb3JtIGZsb2F0IHVSYWJiaXRSb3Q7CnVuaWZvcm0gdmVjMyB1Q2FtZXJhUG9zOwp1bmlmb3JtIHZlYzMgdUNhbWVyYVRhcmdldDsKZmxvYXQgcm5kKHZlYzIgcCkgewogICAgcmV0dXJuIGZyYWN0KHNpbihkb3QocCwgdmVjMigxMy4yMzQsIDcyLjE4NDkpKSkgKiA0MzI1MS4xMjM0KTsKfQpmbG9hdCByb3VuZEJveCh2ZWMzIHAsIHZlYzMgYiwgZmxvYXQgcikgewogICAgcmV0dXJuIGxlbmd0aChtYXgoYWJzKHApIC0gYiwgMC4wKSkgLSByOwp9Cm1hdDIgcm90KGZsb2F0IGEpIHsKICAgICBmbG9hdCBjID0gY29zKGEpLCBzID0gc2luKGEpOwogICAgIHJldHVybiBtYXQyKGMsIC1zLCBzLCBjKTsKfQpmbG9hdCB0cmkoZmxvYXQgeCkgewogICAgcmV0dXJuIGFicyhmcmFjdCh4KSAtIDAuNSk7Cn0KdmVjMyB0cmkzKHZlYzMgcCkgewogICByZXR1cm4gYWJzKGZyYWN0KHAuenp5ICsgYWJzKGZyYWN0KHAueXh4KSAtIDAuNSkpIC0gMC41KTsKfQpmbG9hdCB0cmlOb2lzZTNEKHZlYzMgcCwgZmxvYXQgc3BkKSB7CiAgICBmbG9hdCB6ID0gMS40OwogICAgZmxvYXQgcnogPSAwLjA7CiAgICB2ZWMzIGJwID0gcDsKICAgIGZvciAoZmxvYXQgaSA9IDAuMDsgaSA8PSAzLjA7IGkgKz0gMS4wKSB7CiAgICAgICAgdmVjMyBkZyA9IHRyaTMoYnAgKiAyLjApOwogICAgICAgIHAgKz0gKGRnICsgaVRpbWUgKiAwLjMgKiBzcGQpOwogICAgICAgIGJwICo9IDEuODsKICAgICAgICB6ICo9IDEuNTsKICAgICAgICBwICo9IDEuMjsKICAgICAgICByeiArPSB0cmkocC56ICsgdHJpKHAueCArIHRyaShwLnkpKSkgLyB6OwogICAgICAgIGJwICs9IDAuMTQ7CiAgICB9CiAgICByZXR1cm4gcno7Cn0KZmxvYXQgc3BoZXJlMih2ZWMyIHAsIGZsb2F0IHIpIHsKICAgIHJldHVybiBsZW5ndGgocCkgLSByOwp9CmZsb2F0IGVsbGlwc2UyKHZlYzIgcCwgdmVjMiByKSB7CiAgICBmbG9hdCBrMCA9IGxlbmd0aChwIC8gcik7CiAgICBmbG9hdCBrMSA9IGxlbmd0aChwIC8gKHIgKiByKSk7CiAgICByZXR1cm4gazAgKiAoazAgLSAxLjApIC8gazE7Cn0KZmxvYXQgYmxlbmQoZmxvYXQgZDEsIGZsb2F0IGQyLCBmbG9hdCBrKSB7CiAgICBmbG9hdCBoID0gY2xhbXAoMC41ICsgMC41ICogKGQyIC0gZDEpIC8gaywgMC4wLCAxLjApOwogICAgcmV0dXJuIG1peChkMiwgZDEsIGgpIC0gayAqIGggKiAoMS4wIC0gaCk7Cn0KZmxvYXQgcm91bmRDb25lKHZlYzMgcCwgZmxvYXQgcjEsIGZsb2F0IHIyLCBmbG9hdCBoKSB7CiAgICB2ZWMyIHEgPSB2ZWMyKGxlbmd0aChwLnh6KSwgcC55KTsKICAgIGZsb2F0IGIgPSAocjEgLSByMikgLyBoOwogICAgZmxvYXQgYSA9IHNxcnQoMS4wIC0gYiAqIGIpOwogICAgZmxvYXQgayA9IGRvdChxLCB2ZWMyKC1iLCBhKSk7CiAgICBpZihrIDwgMC4wKSByZXR1cm4gbGVuZ3RoKHEpIC0gcjE7CiAgICBpZihrID4gYSAqIGgpIHJldHVybiBsZW5ndGgocSAtIHZlYzIoMC4wLCBoKSkgLSByMjsKICAgIHJldHVybiBkb3QocSwgdmVjMihhLCBiKSkgLSByMTsKfQpmbG9hdCBkU3BoZXJlKHZlYzMgcCwgZmxvYXQgcikgeyByZXR1cm4gbGVuZ3RoKHApIC0gcjsgfQpmbG9hdCBkVG9ydXMyKHZlYzMgcCwgdmVjMiB0KSB7IHZlYzIgcSA9IHZlYzIobGVuZ3RoKHAueHopIC0gdC54LCBwLnkpOyByZXR1cm4gbGVuZ3RoKHEpIC0gdC55OyB9CmZsb2F0IHlDeWxpbmRlcih2ZWMzIHAsIHZlYzIgaCkgeyByZXR1cm4gbWF4KGxlbmd0aChwLnh6KS1oLngsIGFicyhwLnkpLWgueSk7IH0KZmxvYXQgY2Fwc3VsZVkodmVjMyBwLCBmbG9hdCByLCBmbG9hdCBoKSB7IHAueSAtPSBjbGFtcChwLnksIDAuMCwgaCk7IHJldHVybiBsZW5ndGgocCkgLSByOyB9CmZsb2F0IHNtaW4oZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgaykgeyBmbG9hdCBoID0gY2xhbXAoMC41KzAuNSooYi1hKS9rLCAwLjAsIDEuMCk7IHJldHVybiBtaXgoYiwgYSwgaCkgLSBrKmgqKDEuMC1oKTsgfQpmbG9hdCBzcGhlcmVEaXN0KHZlYzMgcG9zLCBmbG9hdCByYWRpdXMpIHsKICAgIHJldHVybiBsZW5ndGgocG9zKSAtIHJhZGl1czsKfQpmbG9hdCB0b3J1c1NoYXBlKHZlYzMgcG9zLCB2ZWMyIHBhcmFtcykgewogICAgdmVjMiBxID0gdmVjMihsZW5ndGgocG9zLnh6KSAtIHBhcmFtcy54LCBwb3MueSk7CiAgICByZXR1cm4gbGVuZ3RoKHEpIC0gcGFyYW1zLnk7Cn0KZmxvYXQgdmVydEN5bGluZGVyKHZlYzMgcG9zLCB2ZWMyIGRpbSkgewogICAgcmV0dXJuIG1heChsZW5ndGgocG9zLnh6KSAtIGRpbS54LCBhYnMocG9zLnkpIC0gZGltLnkpOwp9CmZsb2F0IGNhcFkodmVjMyBwb3MsIGZsb2F0IHJhZCwgZmxvYXQgaGVpZ2h0KSB7CiAgICBwb3MueSAtPSBjbGFtcChwb3MueSwgMC4wLCBoZWlnaHQpOwogICAgcmV0dXJuIGxlbmd0aChwb3MpIC0gcmFkOwp9CmZsb2F0IHNtb290aE1pbihmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCBibGVuZCkgewogICAgZmxvYXQgaCA9IGNsYW1wKDAuNSArIDAuNSAqIChiIC0gYSkgLyBibGVuZCwgMC4wLCAxLjApOwogICAgcmV0dXJuIG1peChiLCBhLCBoKSAtIGJsZW5kICogaCAqICgxLjAgLSBoKTsKfQpmbG9hdCBob3JzZUJhc2UodmVjMyBjb29yZCwgZmxvYXQgc2NhbGUpIHsKICAgIGZsb2F0IHJlc3VsdCA9IDEuMDsKICAgIGZsb2F0IGJsZW5kRmFjdG9yID0gc2NhbGUgKiAwLjM7CiAgICBmbG9hdCBxMSA9IHNjYWxlICogMC4yNSwgcTIgPSBzY2FsZSAqIDAuNCwgcTMgPSBzY2FsZSAqIDAuNTsKICAgIHJlc3VsdCA9IG1pbihyZXN1bHQsIHNwaGVyZURpc3QoY29vcmQsIHNjYWxlKSk7CiAgICByZXN1bHQgPSBtYXgocmVzdWx0LCBhYnMoY29vcmQueSkgLSAwLjEpOwogICAgcmVzdWx0ID0gc21vb3RoTWluKHJlc3VsdCwgdG9ydXNTaGFwZShjb29yZCArIHZlYzMoMC4sIC1xMSwgMC4pLCB2ZWMyKHEzLCBxMSkpLCBibGVuZEZhY3Rvcik7CiAgICByZXN1bHQgPSBzbW9vdGhNaW4ocmVzdWx0LCB2ZXJ0Q3lsaW5kZXIoY29vcmQgKyB2ZWMzKDAuLCAtKHNjYWxlICsgcTEpLCAwLiksIHZlYzIocTIsIHNjYWxlKSksIGJsZW5kRmFjdG9yKTsKICAgIHJldHVybiByZXN1bHQ7Cn0KZmxvYXQgaG9yc2VNb2RlbCh2ZWMzIHBvc2l0aW9uKSB7CiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICogMC43OwogICAgcG9zaXRpb24ueSArPSAyLjU7CiAgICBmbG9hdCBjb3NWYWwgPSBjb3MoNC43KSwgc2luVmFsID0gc2luKDQuNyk7CiAgICBwb3NpdGlvbi54eiA9IHZlYzIoY29zVmFsICogcG9zaXRpb24ueCAtIHNpblZhbCAqIHBvc2l0aW9uLnosIHNpblZhbCAqIHBvc2l0aW9uLnggKyBjb3NWYWwgKiBwb3NpdGlvbi56KTsKICAgIGZsb2F0IGJhc2VTY2FsZSA9IDEuMDsKICAgIGZsb2F0IGJsZW5kSyA9IGJhc2VTY2FsZSAqIDAuMzsKICAgIGZsb2F0IHMxID0gYmFzZVNjYWxlICogMC4xMCwgczIgPSBiYXNlU2NhbGUgKiAwLjI1LCBzMyA9IGJhc2VTY2FsZSAqIDAuNDsKICAgIGZsb2F0IHM0ID0gYmFzZVNjYWxlICogMC41LCBzNSA9IGJhc2VTY2FsZSAqIDAuNiwgczYgPSBiYXNlU2NhbGUgKiAwLjcsIHM3ID0gYmFzZVNjYWxlICogMC44OwogICAgZmxvYXQgZmluYWxEaXN0ID0gaG9yc2VCYXNlKHBvc2l0aW9uLCBiYXNlU2NhbGUpOwogICAgZmluYWxEaXN0ID0gc21vb3RoTWluKGZpbmFsRGlzdCwgc3BoZXJlRGlzdChwb3NpdGlvbiArIHZlYzMoMC4sIC0oYmFzZVNjYWxlICsgczEpLCAtczIpLCBzNCksIGJsZW5kSyk7CiAgICB2ZWMzIGhlYWRQb3MgPSBwb3NpdGlvbjsKICAgIGZsb2F0IGhlYWREaXN0ID0gc3BoZXJlRGlzdChoZWFkUG9zICsgdmVjMygwLiwgLShiYXNlU2NhbGUgKiAyLjAgKyBzNiksIDAuKSwgczUpOwogICAgaGVhZFBvcyArPSB2ZWMzKDAuLCAtKGJhc2VTY2FsZSAqIDIuMCArIHM1KSwgMC4pOwogICAgZmxvYXQgYW5nbGUgPSAxLjg1OwogICAgZmxvYXQgY29zQSA9IGNvcyhhbmdsZSksIHNpbkEgPSBzaW4oYW5nbGUpOwogICAgaGVhZFBvcy56eSA9IHZlYzIoY29zQSAqIGhlYWRQb3MueiAtIHNpbkEgKiBoZWFkUG9zLnksIHNpbkEgKiBoZWFkUG9zLnogKyBjb3NBICogaGVhZFBvcy55KTsKICAgIGhlYWREaXN0ID0gc21vb3RoTWluKGhlYWREaXN0LCBjYXBZKGhlYWRQb3MgKyB2ZWMzKDAuLCAtKHMxICogMy4wKSwgczEpLCBzMywgYmFzZVNjYWxlKSwgczYpOwogICAgZmluYWxEaXN0ID0gc21vb3RoTWluKGZpbmFsRGlzdCwgaGVhZERpc3QsIGJsZW5kSyk7CiAgICB2ZWMzIGVhclBvcyA9IHBvc2l0aW9uOwogICAgZWFyUG9zLnggPSBhYnMoZWFyUG9zLngpOwogICAgZmxvYXQgZWFyU2hhcGUgPSB0b3J1c1NoYXBlKGVhclBvcyArIHZlYzMoLXMzLCAtKGJhc2VTY2FsZSAqIDMuMCArIHMyKSwgMC4pLCB2ZWMyKC1zNSwgczcpKTsKICAgIGVhclNoYXBlID0gbWF4KGVhclNoYXBlLCAtdG9ydXNTaGFwZShlYXJQb3MgKyB2ZWMzKC1zNSwgLShiYXNlU2NhbGUgKiAzLjAgKyBzMiksIDAuKSwgdmVjMigtczUsIHM3KSkpOwogICAgZmluYWxEaXN0ID0gbWluKGZpbmFsRGlzdCwgZWFyU2hhcGUpOwogICAgdmVjMyBtYW5lUG9zID0gcG9zaXRpb24gKyB2ZWMzKDAuLCAtKGJhc2VTY2FsZSAqIDIuMCArIHMyKSwgczMpOwogICAgdmVjMyBtYW5lT2Zmc2V0ID0gbWFuZVBvcyArIHZlYzMoMC4wLCBjb3MobWFuZVBvcy55ICogczcpICogKC1zNCksIHNpbihtYW5lUG9zLnkgKiAoYmFzZVNjYWxlICogMi4wICsgczcpICsgczQpICogYmxlbmRLKTsKICAgIGZsb2F0IG1hbmVXaWR0aCA9IHMxICogcG93KHNpbihtYW5lT2Zmc2V0LnkgKiAoYmFzZVNjYWxlICogMzAuMCkpLCAyLjApICsgczE7CiAgICBmaW5hbERpc3QgPSBzbW9vdGhNaW4oZmluYWxEaXN0LCB2ZXJ0Q3lsaW5kZXIobWFuZU9mZnNldCwgdmVjMihtYW5lV2lkdGgsIGJhc2VTY2FsZSkpLCBzMik7CiAgICBtYW5lV2lkdGggPSBzMSAqIHBvdyhzaW4obWFuZVBvcy55ICogKGJhc2VTY2FsZSAqIDMwLjApKSwgMi4wKSArIHMxOwogICAgZmluYWxEaXN0ID0gc21vb3RoTWluKGZpbmFsRGlzdCwgdmVydEN5bGluZGVyKG1hbmVQb3MgKyB2ZWMzKDAuLCBzNywgczEpLCB2ZWMyKG1hbmVXaWR0aCwgczcpKSwgczIpOwogICAgcmV0dXJuIGZpbmFsRGlzdDsKfQpmbG9hdCBwYXduKHZlYzMgcG9zKSB7CiAgICBmbG9hdCByYWRpYWxEaXN0ID0gbGVuZ3RoKHBvcy54eik7CiAgICB2ZWMyIGNyb3NzU2VjdGlvbiA9IHZlYzIocmFkaWFsRGlzdCwgcG9zLnkpOwogICAgdmVjMiB0b3BPZmZzZXQgPSBjcm9zc1NlY3Rpb24gLSB2ZWMyKDAuMCwgMS4xKTsKICAgIGZsb2F0IHRvcEJhbGwgPSBsZW5ndGgodG9wT2Zmc2V0KSAtIDAuOTg7CiAgICB2ZWMyIG5lY2tDZW50ZXIgPSB2ZWMyKDAuMCwgLTAuMTIpOwogICAgdmVjMiBuZWNrUmFkaWkgPSB2ZWMyKDAuOTcsIDAuMzEpOwogICAgZmxvYXQgbmVja1JpbmcgPSBlbGxpcHNlMihjcm9zc1NlY3Rpb24gLSBuZWNrQ2VudGVyLCBuZWNrUmFkaWkpOwogICAgZmxvYXQgd2Fpc3RVcHBlciA9IGVsbGlwc2UyKGNyb3NzU2VjdGlvbiAtIHZlYzIoMC4wLCAwLjA1KSwgdmVjMigwLjQ4LCAwLjgyKSk7CiAgICBmbG9hdCB3YWlzdExvd2VyID0gZWxsaXBzZTIoY3Jvc3NTZWN0aW9uIC0gdmVjMigwLjAsIC0yLjI1KSwgdmVjMigwLjg3LCAwLjMxKSk7CiAgICBmbG9hdCB3YWlzdE1pZGRsZSA9IGVsbGlwc2UyKGNyb3NzU2VjdGlvbiAtIHZlYzIoMC4wLCAtMi4wNSksIHZlYzIoMS4zNywgMC4zMSkpOwogICAgZmxvYXQgYmFzZUxvd2VyID0gZWxsaXBzZTIoY3Jvc3NTZWN0aW9uIC0gdmVjMigwLjAsIC0yLjI1KSwgdmVjMigxLjE3LCAwLjYxKSk7CiAgICBmbG9hdCBiYXNlTWlkZGxlID0gZWxsaXBzZTIoY3Jvc3NTZWN0aW9uIC0gdmVjMigwLjAsIC0zLjI1KSwgdmVjMigxLjk3LCAwLjYxKSk7CiAgICBmbG9hdCBiYXNlQm90dG9tID0gZWxsaXBzZTIoY3Jvc3NTZWN0aW9uIC0gdmVjMigwLjAsIC0zLjc1KSwgdmVjMigyLjA3LCAwLjUxKSk7CiAgICBmbG9hdCBoZWFkU2VjdGlvbiA9IGJsZW5kKHRvcEJhbGwsIG5lY2tSaW5nLCAwLjMpOwogICAgZmxvYXQgd2Fpc3RCbGVuZCA9IGJsZW5kKHdhaXN0VXBwZXIsIHdhaXN0TG93ZXIsIDMuMCk7CiAgICBmbG9hdCBiYXNlQmxlbmQgPSBibGVuZChiYXNlTG93ZXIsIGJhc2VNaWRkbGUsIDEuMik7CiAgICBmbG9hdCBjb21wbGV0ZUJhc2UgPSBibGVuZChiYXNlQmxlbmQsIGJhc2VCb3R0b20sIDAuMyk7CiAgICBmbG9hdCByZXN1bHQgPSBtaW4oaGVhZFNlY3Rpb24sIHdhaXN0QmxlbmQpOwogICAgcmVzdWx0ID0gbWluKHJlc3VsdCwgd2Fpc3RNaWRkbGUpOwogICAgcmVzdWx0ID0gbWluKHJlc3VsdCwgY29tcGxldGVCYXNlKTsKICAgIHJldHVybiByZXN1bHQ7Cn0KZmxvYXQgYmFzZTEodmVjMyBwb3MpIHsKICAgIHZlYzIgcHJvZmlsZSA9IHZlYzIobGVuZ3RoKHBvcy54eiksIHBvcy55KTsKICAgIGZsb2F0IG5lY2tQYXJ0ID0gZWxsaXBzZTIocHJvZmlsZSAtIHZlYzIoMC4wLCAtMC45OCksIHZlYzIoMS4yOCwgMS4wMikpOwogICAgZmxvYXQgcmluZzEgPSBlbGxpcHNlMihwcm9maWxlIC0gdmVjMigwLjAsIC0yLjI4KSwgdmVjMigxLjU3LCAwLjYxKSk7CiAgICBmbG9hdCByaW5nMiA9IGVsbGlwc2UyKHByb2ZpbGUgLSB2ZWMyKDAuMCwgLTMuMjgpLCB2ZWMyKDIuNDcsIDAuNjEpKTsKICAgIGZsb2F0IHJpbmczID0gZWxsaXBzZTIocHJvZmlsZSAtIHZlYzIoMC4wLCAtMy43OCksIHZlYzIoMi41NywgMC41MSkpOwogICAgZmxvYXQgYmFuZCA9IGVsbGlwc2UyKHByb2ZpbGUgLSB2ZWMyKDAuMCwgLTIuMDgpLCB2ZWMyKDEuNzcsIDAuMzEpKTsKICAgIGZsb2F0IG1lcmdlZCA9IGJsZW5kKHJpbmcxLCByaW5nMiwgMS4wKTsKICAgIG1lcmdlZCA9IGJsZW5kKG1lcmdlZCwgcmluZzMsIDAuMyk7CiAgICBtZXJnZWQgPSBtaW4obWVyZ2VkLCBiYW5kKTsKICAgIHJldHVybiBtZXJnZWQ7Cn0KZmxvYXQgYmFzZTIodmVjMyBwb3MpIHsKICAgIGZsb2F0IHBlZGVzdGFsID0gYmFzZTEocG9zKTsKICAgIHZlYzIgc2lkZVZpZXcgPSB2ZWMyKGxlbmd0aChwb3MueHopLCBwb3MueSk7CiAgICBmbG9hdCBtYWluQ29sdW1uID0gZWxsaXBzZTIoc2lkZVZpZXcgLSB2ZWMyKDAuMCwgLTEuMzgpLCB2ZWMyKDEuMTMsIDIuNzIpKTsKICAgIGZsb2F0IGNyb3duMSA9IGVsbGlwc2UyKHNpZGVWaWV3IC0gdmVjMigwLjAsIDIuMDIpLCB2ZWMyKDEuNTgsIDAuMzEpKTsKICAgIGZsb2F0IGNyb3duMiA9IGVsbGlwc2UyKHNpZGVWaWV3IC0gdmVjMigwLjAsIDIuMjIpLCB2ZWMyKDEuNDgsIDAuMjEpKTsKICAgIGZsb2F0IGNyb3duMyA9IGVsbGlwc2UyKHNpZGVWaWV3IC0gdmVjMigwLjAsIDIuODIpLCB2ZWMyKDEuMTgsIDAuMjEpKTsKICAgIGZsb2F0IHRvcFNwaGVyZSA9IGVsbGlwc2UyKHNpZGVWaWV3IC0gdmVjMigwLjAsIDUuOTIpLCB2ZWMyKDEuODgsIDIuODIpKTsKICAgIGZsb2F0IGN1dFZvbHVtZSA9IHJvdW5kQm94KHBvcyAtIHZlYzMoMC4wLCA3LjIyLCAwLjApLCB2ZWMzKDIuOTgsIDIuNTIsIDIuOTgpLCAwLjApOwogICAgcGVkZXN0YWwgPSBibGVuZChwZWRlc3RhbCwgbWFpbkNvbHVtbiwgMS44KTsKICAgIHBlZGVzdGFsID0gYmxlbmQocGVkZXN0YWwsIGNyb3duMSwgMS44KTsKICAgIHBlZGVzdGFsID0gbWluKHBlZGVzdGFsLCBjcm93bjIpOwogICAgcGVkZXN0YWwgPSBibGVuZChwZWRlc3RhbCwgY3Jvd24zLCAwLjU1KTsKICAgIHBlZGVzdGFsID0gYmxlbmQocGVkZXN0YWwsIHRvcFNwaGVyZSwgMS4xKTsKICAgIHJldHVybiBtYXgocGVkZXN0YWwsIC1jdXRWb2x1bWUpOwp9CmZsb2F0IHJvb2sodmVjMyBwb3NpdGlvbikgewogICAgZmxvYXQgZm91bmRhdGlvbiA9IGJhc2UxKHBvc2l0aW9uKTsKICAgIHZlYzIgc2lsaG91ZXR0ZSA9IHZlYzIobGVuZ3RoKHBvc2l0aW9uLnh6KSwgcG9zaXRpb24ueSk7CiAgICB2ZWMyIG5lY2tQb3MgPSBzaWxob3VldHRlIC0gdmVjMigwLjAsIC0wLjk4KTsKICAgIGZsb2F0IHRvd2VyTmVjayA9IGVsbGlwc2UyKG5lY2tQb3MsIHZlYzIoMS4xOCwgMS4zMikpOwogICAgdmVjMiByaW1Qb3MgPSBzaWxob3VldHRlIC0gdmVjMigwLjAsIDAuNTIpOwogICAgZmxvYXQgY3Jvd25SaW0gPSBlbGxpcHNlMihyaW1Qb3MsIHZlYzIoMS42OCwgMC4yMSkpOwogICAgZmxvYXQgdG93ZXIgPSBibGVuZChmb3VuZGF0aW9uLCB0b3dlck5lY2ssIDEuMCk7CiAgICB0b3dlciA9IGJsZW5kKHRvd2VyLCBjcm93blJpbSwgMS40KTsKICAgIHZlYzMgbWVybG9uT2Zmc2V0ID0gdmVjMyhzaWxob3VldHRlLngsIHBvc2l0aW9uLnksIDAuMCkgLSB2ZWMzKDEuMzgsIDEuMTIsIDAuMCk7CiAgICBmbG9hdCBzaW5nbGVNZXJsb24gPSByb3VuZEJveChtZXJsb25PZmZzZXQsIHZlYzMoMC4yMSwgMC42MSwgMS45OCksIDAuMCk7CiAgICB0b3dlciA9IG1pbih0b3dlciwgc2luZ2xlTWVybG9uKTsKICAgIHZlYzMgcm90YXRlZFBvcyA9IHBvc2l0aW9uOwogICAgZmxvYXQgcm90YXRpb25BbmdsZSA9IDIuMDk0Mzk1OwogICAgZmxvYXQgY29zQSA9IGNvcyhyb3RhdGlvbkFuZ2xlKTsKICAgIGZsb2F0IHNpbkEgPSBzaW4ocm90YXRpb25BbmdsZSk7CiAgICBtYXQyIHJvdGF0aW9uTWF0cml4ID0gbWF0Mihjb3NBLCAtc2luQSwgc2luQSwgY29zQSk7CiAgICBmb3IgKGludCBzbG90ID0gMDsgc2xvdCA8IDM7IHNsb3QrKykgewogICAgICAgIHZlYzMgZ2FwQm94ID0gcm90YXRlZFBvcyAtIHZlYzMoMC4wLCAxLjQyLCAwLjApOwogICAgICAgIGZsb2F0IGdhcCA9IHJvdW5kQm94KGdhcEJveCwgdmVjMygxLjk4LCAwLjYxLCAwLjIxKSwgMC4wKTsKICAgICAgICB0b3dlciA9IG1heCh0b3dlciwgLWdhcCk7CiAgICAgICAgcm90YXRlZFBvcy54eiA9IHJvdGF0aW9uTWF0cml4ICogcm90YXRlZFBvcy54ejsKICAgIH0KICAgIHJldHVybiB0b3dlcjsKfQpmbG9hdCBrbmlnaHQodmVjMyBjb29yZCkgewogICAgZmxvYXQgcGxhdGZvcm0gPSBiYXNlMShjb29yZCk7CiAgICBjb29yZC54ID0gYWJzKGNvb3JkLngpOwogICAgdmVjMyBib2R5Q2VudGVyID0gY29vcmQgLSB2ZWMzKDAuMCwgMi4wMiwgMC4wKTsKICAgIGZsb2F0IG91dGVyQm91bmQgPSBsZW5ndGgoYm9keUNlbnRlcikgLSAzLjk3OwogICAgdmVjMyBzY2FsZWRCb2R5ID0gYm9keUNlbnRlciAvIHZlYzMoMS45OCwgNS4wMiwgMS43OCk7CiAgICBmbG9hdCBpbm5lckJvdW5kID0gKGxlbmd0aChzY2FsZWRCb2R5KSAtIDEuMCkgKiAxLjc4OwogICAgdmVjMyBuZWNrQmFzZSA9IGNvb3JkIC0gdmVjMygtMC4yOCwgMS4wMiwgMC41Mik7CiAgICBmbG9hdCBuZWNrVHJ1bmsgPSByb3VuZENvbmUobmVja0Jhc2UsIDAuNzgsIDIuMjIsIDIuMTgpOwogICAgdmVjMyBjdXRTY2FsZSA9IChjb29yZCAtIHZlYzMoMi4xOCwgMC4wLCAwLjApKSAvIHZlYzMoMS40OCwgMi41MiwgNC45OCk7CiAgICBmbG9hdCBzaWRlQ3V0ID0gKGxlbmd0aChjdXRTY2FsZSkgLSAxLjApICogMS40ODsKICAgIGZsb2F0IHRpbHRBbmdsZSA9IDEuMzI7CiAgICBmbG9hdCBjb3NUID0gY29zKHRpbHRBbmdsZSk7CiAgICBmbG9hdCBzaW5UID0gc2luKHRpbHRBbmdsZSk7CiAgICBtYXQzIHRpbHRNYXRyaXggPSBtYXQzKDEuMCwgMC4wLCAwLjAsIDAuMCwgY29zVCwgLXNpblQsIDAuMCwgc2luVCwgY29zVCk7CiAgICB2ZWMzIGhlYWRCYXNlID0gY29vcmQgLSB2ZWMzKDAuMCwgMi41MiwgMC41Mik7CiAgICBmbG9hdCBoZWFkQ29uZSA9IHJvdW5kQ29uZSh0aWx0TWF0cml4ICogaGVhZEJhc2UsIDEuMTgsIDAuNTgsIDEuNCk7CiAgICBmb3IoaW50IGkgPSAwOyBpIDwgODsgaSsrKSB7CiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gZmxvYXQoaSkgKiAwLjE1OwogICAgICAgIHZlYzMgbWFuZVBvcyA9IGNvb3JkIC0gdmVjMygwLjAsIDIuNSAtIG9mZnNldCwgLTAuMyk7CiAgICAgICAgZmxvYXQgbWFuZUdyb292ZSA9IGxlbmd0aChtYW5lUG9zLnh6KSAtIDAuMDU7CiAgICAgICAgaGVhZENvbmUgPSBtYXgoaGVhZENvbmUsIC1tYW5lR3Jvb3ZlKTsKICAgIH0KICAgIGZsb2F0IHBsYW5lQ3V0ID0gMC41MiAtIGNvb3JkLng7CiAgICB2ZWMzIHJlYXJDdXRDZW50ZXIgPSBjb29yZCAtIHZlYzMoMi4wOCwgMi44MiwgLTEuODgpOwogICAgZmxvYXQgcmVhckN1dCA9IGxlbmd0aChyZWFyQ3V0Q2VudGVyKSAtIDEuOTg7CiAgICB2ZWMzIHNob3VsZGVyU2NhbGUgPSAoY29vcmQgLSB2ZWMzKDAuMCwgMi4yMiwgMC4wKSkgLyB2ZWMzKDEuOTgsIDEuMjgsIDIuMjgpOwogICAgZmxvYXQgc2hvdWxkZXJNYXNzID0gKGxlbmd0aChzaG91bGRlclNjYWxlKSAtIDEuMCkgKiAxLjI4OwogICAgZmxvYXQgbmVja0Fzc2VtYmx5ID0gbWF4KG5lY2tUcnVuaywgLXNpZGVDdXQpOwogICAgZmxvYXQgaGVhZEFzc2VtYmx5ID0gaGVhZENvbmU7CiAgICBoZWFkQXNzZW1ibHkgPSBtYXgoaGVhZEFzc2VtYmx5LCAtcGxhbmVDdXQpOwogICAgaGVhZEFzc2VtYmx5ID0gbWF4KGhlYWRBc3NlbWJseSwgLXJlYXJDdXQpOwogICAgaGVhZEFzc2VtYmx5ID0gbWF4KGhlYWRBc3NlbWJseSwgc2hvdWxkZXJNYXNzKTsKICAgIG5lY2tBc3NlbWJseSA9IGJsZW5kKG5lY2tBc3NlbWJseSwgaGVhZEFzc2VtYmx5LCAwLjcyKTsKICAgIGZsb2F0IGhvcnNlQm9keSA9IG1pbihwbGF0Zm9ybSwgbWF4KG1heChuZWNrQXNzZW1ibHksIG91dGVyQm91bmQpLCBpbm5lckJvdW5kKSk7CiAgICByZXR1cm4gaG9yc2VCb2R5Owp9CmZsb2F0IGJpc2hvcCh2ZWMzIGxvYykgewogICAgZmxvYXQgc3RhbmQgPSBiYXNlMShsb2MpOwogICAgdmVjMiBvdXRsaW5lID0gdmVjMihsZW5ndGgobG9jLnh6KSwgbG9jLnkpOwogICAgdmVjMiBzdGVtQ2VudGVyID0gb3V0bGluZSAtIHZlYzIoMC4wLCAtMS4zOCk7CiAgICBmbG9hdCBib2R5U3RlbSA9IGVsbGlwc2UyKHN0ZW1DZW50ZXIsIHZlYzIoMC45OCwgMS42MikpOwogICAgZmxvYXQgY2FwUmluZzEgPSBlbGxpcHNlMihvdXRsaW5lIC0gdmVjMigwLjAsIDAuNzIpLCB2ZWMyKDEuNTgsIDAuMzEpKTsKICAgIGZsb2F0IGNhcFJpbmcyID0gZWxsaXBzZTIob3V0bGluZSAtIHZlYzIoMC4wLCAwLjkyKSwgdmVjMigxLjQ4LCAwLjIxKSk7CiAgICBmbG9hdCBjYXBSaW5nMyA9IGVsbGlwc2UyKG91dGxpbmUgLSB2ZWMyKDAuMCwgMS41MiksIHZlYzIoMS4xOCwgMC4yMSkpOwogICAgdmVjMiBtaXRyZUNlbnRlciA9IG91dGxpbmUgLSB2ZWMyKDAuMCwgMi42Mik7CiAgICBmbG9hdCBtaXRyZSA9IGVsbGlwc2UyKG1pdHJlQ2VudGVyLCB2ZWMyKDEuMjgsIDEuNTIpKTsKICAgIHZlYzIgdGlwQ2VudGVyID0gb3V0bGluZSAtIHZlYzIoMC4wLCA0LjIyKTsKICAgIGZsb2F0IHRpcCA9IGVsbGlwc2UyKHRpcENlbnRlciwgdmVjMigwLjM4LCAwLjM4KSk7CiAgICBmbG9hdCBzbGl0QW5nbGUgPSAtMC40MjsKICAgIGZsb2F0IGNvc1MgPSBjb3Moc2xpdEFuZ2xlKTsKICAgIGZsb2F0IHNpblMgPSBzaW4oc2xpdEFuZ2xlKTsKICAgIG1hdDIgc2xpdFJvdGF0aW9uID0gbWF0Mihjb3NTLCAtc2luUywgc2luUywgY29zUyk7CiAgICB2ZWMzIHNsaXRQb3MgPSBsb2MgLSB2ZWMzKDAuNzgsIDMuNzIsIDAuMCk7CiAgICB2ZWMyIHJvdGF0ZWRTbGl0ID0gc2xpdFJvdGF0aW9uICogc2xpdFBvcy54eTsKICAgIHZlYzMgc2xpdEJveCA9IHZlYzMocm90YXRlZFNsaXQsIHNsaXRQb3Mueik7CiAgICBmbG9hdCBzbGl0ID0gcm91bmRCb3goc2xpdEJveCwgdmVjMygwLjIxLCAwLjk4LCAxLjk4KSwgMC4wKTsKICAgIGZsb2F0IGJpc2hvcFNoYXBlID0gYmxlbmQoc3RhbmQsIGJvZHlTdGVtLCAwLjkyKTsKICAgIGJpc2hvcFNoYXBlID0gYmxlbmQoYmlzaG9wU2hhcGUsIGNhcFJpbmcxLCAxLjUyKTsKICAgIGJpc2hvcFNoYXBlID0gbWluKGJpc2hvcFNoYXBlLCBjYXBSaW5nMik7CiAgICBiaXNob3BTaGFwZSA9IGJsZW5kKGJpc2hvcFNoYXBlLCBjYXBSaW5nMywgMC41Nyk7CiAgICBiaXNob3BTaGFwZSA9IG1pbihiaXNob3BTaGFwZSwgbWl0cmUpOwogICAgYmlzaG9wU2hhcGUgPSBtaW4oYmlzaG9wU2hhcGUsIHRpcCk7CiAgICBiaXNob3BTaGFwZSA9IG1heChiaXNob3BTaGFwZSwgLXNsaXQpOwogICAgcmV0dXJuIGJpc2hvcFNoYXBlOwp9CmZsb2F0IGtpbmcodmVjMyBwdCkgewogICAgZmxvYXQgYmFzZSA9IGJhc2UyKHB0KTsKICAgIHZlYzIgcHJvZmlsZSA9IHZlYzIobGVuZ3RoKHB0Lnh6KSwgcHQueSk7CiAgICB2ZWMyIGRpc2tDZW50ZXIgPSBwcm9maWxlIC0gdmVjMigwLjAsIDQuNjIpOwogICAgZmxvYXQgY3Jvd25EaXNrID0gZWxsaXBzZTIoZGlza0NlbnRlciwgdmVjMigxLjc4LCAwLjQyKSk7CiAgICB2ZWMzIHZCZWFtUG9zID0gcHQgLSB2ZWMzKDAuMCwgNS4yMiwgMC4wKTsKICAgIGZsb2F0IHZlcnRpY2FsQmVhbSA9IHJvdW5kQm94KHZCZWFtUG9zLCB2ZWMzKDAuMjgsIDEuNTIsIDAuMjMpLCAwLjApOwogICAgdmVjMyBoQmVhbVBvcyA9IHB0IC0gdmVjMygwLjAsIDUuODIsIDAuMCk7CiAgICBmbG9hdCBob3Jpem9udGFsQmVhbSA9IHJvdW5kQm94KGhCZWFtUG9zLCB2ZWMzKDAuOTgsIDAuMjgsIDAuMjMpLCAwLjApOwogICAgZmxvYXQga2luZ1BpZWNlID0gbWluKGJhc2UsIGNyb3duRGlzayk7CiAgICBraW5nUGllY2UgPSBtaW4oa2luZ1BpZWNlLCB2ZXJ0aWNhbEJlYW0pOwogICAga2luZ1BpZWNlID0gbWluKGtpbmdQaWVjZSwgaG9yaXpvbnRhbEJlYW0pOwogICAgcmV0dXJuIGtpbmdQaWVjZTsKfQpmbG9hdCBxdWVlbih2ZWMzIHBvaW50KSB7CiAgICBmbG9hdCBwZWRlc3RhbCA9IGJhc2UyKHBvaW50KTsKICAgIHZlYzIgY3Jvc3NTZWMgPSB2ZWMyKGxlbmd0aChwb2ludC54eiksIHBvaW50LnkpOwogICAgdmVjMiBjcm93bkNlbnRlciA9IGNyb3NzU2VjIC0gdmVjMigwLjAsIDQuMDIpOwogICAgZmxvYXQgY3Jvd25Cb2R5ID0gZWxsaXBzZTIoY3Jvd25DZW50ZXIsIHZlYzIoMS4yOCwgMS41MikpOwogICAgdmVjMiBjdXRDZW50ZXIgPSBjcm9zc1NlYyAtIHZlYzIoMC4wLCAyLjAyKTsKICAgIGZsb2F0IGNyb3duQ3V0ID0gcm91bmRCb3godmVjMyhjdXRDZW50ZXIsIDAuMCksIHZlYzMoMi45OCwgMi4wMiwgMi45OCksIDAuMCk7CiAgICB2ZWMyIG9yYkNlbnRlciA9IGNyb3NzU2VjIC0gdmVjMigwLjAsIDUuNjIpOwogICAgZmxvYXQgdG9wT3JiID0gZWxsaXBzZTIob3JiQ2VudGVyLCB2ZWMyKDAuNDgsIDAuNDgpKTsKICAgIHZlYzMgYWJzUG9pbnQgPSB2ZWMzKGFicyhwb2ludC54KSwgcG9pbnQueSwgYWJzKHBvaW50LnopKTsKICAgIGlmIChhYnNQb2ludC54ID4gYWJzUG9pbnQueikgewogICAgICAgIGFic1BvaW50ID0gYWJzUG9pbnQuenl4OwogICAgfQogICAgdmVjMyBub3RjaENlbnRlciA9IGFic1BvaW50IC0gdmVjMygwLjk4LCA0LjcyLCAyLjE4KTsKICAgIGZsb2F0IGNvcm5lck5vdGNoID0gbGVuZ3RoKG5vdGNoQ2VudGVyKSAtIDEuMDg7CiAgICBmbG9hdCBxdWVlblNoYXBlID0gbWluKHBlZGVzdGFsLCBtYXgoY3Jvd25Cb2R5LCAtY3Jvd25DdXQpKTsKICAgIHF1ZWVuU2hhcGUgPSBtaW4ocXVlZW5TaGFwZSwgdG9wT3JiKTsKICAgIHF1ZWVuU2hhcGUgPSBtYXgocXVlZW5TaGFwZSwgLWNvcm5lck5vdGNoKTsKICAgIHJldHVybiBxdWVlblNoYXBlOwp9CmZsb2F0IHRvcnVzSG9yaXpvbnRhbCh2ZWMzIHBvc2l0aW9uLCBmbG9hdCBtYWpvclJhZCwgZmxvYXQgbWlub3JSYWQpIHsKICAgIHZlYzIgcmFkaWFsQ29tcCA9IHZlYzIobGVuZ3RoKHBvc2l0aW9uLnh5KSAtIG1ham9yUmFkLCBwb3NpdGlvbi56KTsKICAgIHJldHVybiBsZW5ndGgocmFkaWFsQ29tcCkgLSBtaW5vclJhZDsKfQpmbG9hdCB0b3J1c1ZlcnRpY2FsKHZlYzMgcG9zaXRpb24sIGZsb2F0IG1ham9yUmFkLCBmbG9hdCBtaW5vclJhZCkgewogICAgdmVjMiByYWRpYWxDb21wID0gdmVjMihsZW5ndGgocG9zaXRpb24ueXopIC0gbWFqb3JSYWQsIHBvc2l0aW9uLngpOwogICAgcmV0dXJuIGxlbmd0aChyYWRpYWxDb21wKSAtIG1pbm9yUmFkOwp9CmZsb2F0IGNsb2NrU3BoZXJlKHZlYzMgcG9zaXRpb24pIHsKICAgIHJldHVybiBsZW5ndGgocG9zaXRpb24pIC0gMS4xODsKfQpmbG9hdCBnZXRDbG9ja1BhdHRlcm4odmVjMyBwKSB7CiAgICB2ZWMzIG5wID0gbm9ybWFsaXplKHApOwogICAgZmxvYXQgYSA9IChhdGFuKG5wLngsIG5wLnopICsgMy4xNDE1OSkgLyA2LjI4MzE4OwogICAgZmxvYXQgbCA9IGxlbmd0aCh2ZWMyKG5wLngsIG5wLnopKTsKICAgIGZsb2F0IGxsID0gYSAqIDIuMCArIHBvdyhsLCAwLjMpICogNy4wOwogICAgbGwgPSBmcmFjdChsbCk7CiAgICBmbG9hdCByYSA9IGEgKiAyNC4wIC0gaVRpbWU7CiAgICBmbG9hdCBiZ2xpbmUgPSBzdGVwKDAuMDIsIGFicyhsbCAtIDAuNjUpIC0gMC4zNSk7CiAgICBmbG9hdCBudW0gPSBzdGVwKDAuMywgZnJhY3QocmEpICogMi4wIC0gMC41KTsKICAgIHJldHVybiBtaXgoMC4zLCAwLjksIGJnbGluZSAqIG51bSk7Cn0KZmxvYXQgR2V0RGlzdGFuY2VDaGFpbih2ZWMzIHZQb3MpIHsKICAgIHZlYzMgdkNoYWluRG9tYWluID0gdlBvczsKICAgIHZDaGFpbkRvbWFpbi55ID0gZnJhY3QodkNoYWluRG9tYWluLnkgKyAwLjUpIC0gMC41OwogICAgZmxvYXQgZkRpc3RUb3J1czEgPSB0b3J1c0hvcml6b250YWwodkNoYWluRG9tYWluLCAwLjU1LCAwLjE1KTsKICAgIHZDaGFpbkRvbWFpbi55ID0gZnJhY3QodlBvcy55ICsgMS4wKSAtIDAuNTsKICAgIGZsb2F0IGZEaXN0VG9ydXMyID0gdG9ydXNWZXJ0aWNhbCh2Q2hhaW5Eb21haW4sIDAuNTUsIDAuMTUpOwogICAgcmV0dXJuIG1pbihmRGlzdFRvcnVzMSwgZkRpc3RUb3J1czIpOwp9CmZsb2F0IGNoZXNzRmllbGQodmVjMyBwKSB7CiAgICB2ZWMzIGlkID0gZmxvb3IocCAvIDEwLjApOwogICAgdmVjMyBsb2NhbFAgPSBtb2QocCwgMTAuMCkgLSA1LjA7CiAgICBmbG9hdCByYW5kVmFsID0gcm5kKGlkLnh6ICsgdmVjMihpZC55ICogMTAuMCkpOwogICAgYm9vbCBpc0dyb3VuZExldmVsID0gKGlkLnkgPT0gMC4wKTsKICAgIGJvb2wgaXNVbmRlcmdyb3VuZCA9IChpZC55IDwgMC4wKTsKICAgIGZsb2F0IHBpZWNlVHlwZSA9IGZyYWN0KHJhbmRWYWwgKiA2LjApOwogICAgdmVjMyBvYmpXb3JsZFBvcyA9IHZlYzMoaWQueCAqIDEwLjAsIGlkLnkgKiAxMC4wLCBpZC56ICogMTAuMCk7CiAgICBmbG9hdCBkaXN0VG9DYW1lcmEgPSBsZW5ndGgob2JqV29ybGRQb3MgLSB1Q2FtZXJhUG9zKTsKICAgIGJvb2wgaXNUb29GYXIgPSBkaXN0VG9DYW1lcmEgPiA4MC4wOwogICAgYm9vbCBhbGxvd0FuaW1hdGlvbiA9ICFpc1Rvb0ZhciAmJiAhaXNVbmRlcmdyb3VuZDsKICAgIGZsb2F0IGFuaW1UaW1lID0gYWxsb3dBbmltYXRpb24gPyBpVGltZSAqIChyYW5kVmFsICogMi4wIC0gMS4wKSAqIDAuOCA6IDAuMDsKICAgIGZsb2F0IHJvdEFuZ2xlID0gYWxsb3dBbmltYXRpb24gPyBpVGltZSAqIChyYW5kVmFsICogMi4wIC0gMS4wKSAqIDAuOCA6IDAuMDsKICAgIGZsb2F0IHBpZWNlOwogICAgaWYgKHBpZWNlVHlwZSA8IDAuMDkpIHsKICAgICAgICB2ZWMzIGNoYWluUCA9IGxvY2FsUDsKICAgICAgICBpZiAoaXNHcm91bmRMZXZlbCAmJiBhbGxvd0FuaW1hdGlvbikgewogICAgICAgICAgICBjaGFpblAueSArPSBzaW4oaVRpbWUpICsgMy41OwogICAgICAgIH0gZWxzZSBpZiAoaXNHcm91bmRMZXZlbCkgewogICAgICAgICAgICBjaGFpblAueSArPSAzLjU7CiAgICAgICAgfQogICAgICAgIHBpZWNlID0gR2V0RGlzdGFuY2VDaGFpbihjaGFpblApOwogICAgfSBlbHNlIGlmIChwaWVjZVR5cGUgPCAwLjI0KSB7CiAgICAgICAgdmVjMyBjbG9ja1AgPSBsb2NhbFA7CiAgICAgICAgaWYgKGFsbG93QW5pbWF0aW9uKSB7CiAgICAgICAgICAgIGZsb2F0IG1vdmVTcGVlZCA9IChyYW5kVmFsICogMi4wIC0gMS4wKSAqIDAuMzsKICAgICAgICAgICAgZmxvYXQgbW92ZVRpbWUgPSBpVGltZSAqIG1vdmVTcGVlZDsKICAgICAgICAgICAgZmxvYXQgb3JiaXRSYWRpdXMgPSAxLjU7CiAgICAgICAgICAgIGZsb2F0IG9yYml0QW5nbGUgPSBtb3ZlVGltZSArIHJhbmRWYWwgKiA2LjI4OwogICAgICAgICAgICBjbG9ja1AueCArPSBjb3Mob3JiaXRBbmdsZSkgKiBvcmJpdFJhZGl1czsKICAgICAgICAgICAgY2xvY2tQLnogKz0gc2luKG9yYml0QW5nbGUpICogb3JiaXRSYWRpdXM7CiAgICAgICAgICAgIGZsb2F0IHZlcnRpY2FsU3BlZWQgPSAocmFuZFZhbCAqIDIuMCAtIDEuMCkgKiAwLjg7CiAgICAgICAgICAgIGZsb2F0IHZlcnRpY2FsUGhhc2UgPSByYW5kVmFsICogNi4yODsKICAgICAgICAgICAgZmxvYXQgdmVydGljYWxPZmZzZXQgPSBzaW4oaVRpbWUgKiB2ZXJ0aWNhbFNwZWVkICsgdmVydGljYWxQaGFzZSkgKiAxLjI7CiAgICAgICAgICAgIGNsb2NrUC55ICs9IDEuMiArIHZlcnRpY2FsT2Zmc2V0OwogICAgICAgICAgICBmbG9hdCByb3RTcGVlZCA9IChyYW5kVmFsICogMi4wIC0gMS4wKSAqIDAuNTsKICAgICAgICAgICAgZmxvYXQgYW5nbGUgPSBpVGltZSAqIHJvdFNwZWVkOwogICAgICAgICAgICBmbG9hdCBjID0gY29zKGFuZ2xlKSwgcyA9IHNpbihhbmdsZSk7CiAgICAgICAgICAgIGNsb2NrUC54eiA9IHZlYzIoYyAqIGNsb2NrUC54IC0gcyAqIGNsb2NrUC56LCBzICogY2xvY2tQLnggKyBjICogY2xvY2tQLnopOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNsb2NrUC55ICs9IDEuMjsKICAgICAgICB9CiAgICAgICAgcGllY2UgPSBjbG9ja1NwaGVyZShjbG9ja1ApOwogICAgfSBlbHNlIGlmIChwaWVjZVR5cGUgPCAwLjM1KSB7CiAgICAgICAgZmxvYXQgdGlsdCA9IHNpbihhbmltVGltZSAqIDIuMCkgKiAwLjI7CiAgICAgICAgZmxvYXQgYzEgPSBjb3ModGlsdCksIHMxID0gc2luKHRpbHQpOwogICAgICAgIHZlYzMgcCA9IGxvY2FsUDsKICAgICAgICBwLnh5ID0gdmVjMihjMSAqIGxvY2FsUC54IC0gczEgKiBsb2NhbFAueSwgczEgKiBsb2NhbFAueCArIGMxICogbG9jYWxQLnkpOwogICAgICAgIGZsb2F0IGMgPSBjb3MoLXJvdEFuZ2xlICogMC41KSwgcyA9IHNpbigtcm90QW5nbGUgKiAwLjUpOwogICAgICAgIHAueHogPSB2ZWMyKGMgKiBwLnggLSBzICogcC56LCBzICogcC54ICsgYyAqIHAueik7CiAgICAgICAgcGllY2UgPSBwYXduKHApOwogICAgfSBlbHNlIGlmIChwaWVjZVR5cGUgPCAwLjM4KSB7CiAgICAgICAgZmxvYXQgYyA9IGNvcygtcm90QW5nbGUpLCBzID0gc2luKC1yb3RBbmdsZSk7CiAgICAgICAgdmVjMyBwID0gbG9jYWxQOwogICAgICAgIHAueHogPSB2ZWMyKGMgKiBsb2NhbFAueCAtIHMgKiBsb2NhbFAueiwgcyAqIGxvY2FsUC54ICsgYyAqIGxvY2FsUC56KTsKICAgICAgICBwLnogKz0gc2luKGFuaW1UaW1lICogMi41KSAqIDAuNDsKICAgICAgICBwaWVjZSA9IHJvb2socCk7CiAgICB9IGVsc2UgaWYgKHBpZWNlVHlwZSA8IDAuNTQpIHsKICAgICAgICBmbG9hdCBjID0gY29zKC1yb3RBbmdsZSAqIDEuNSksIHMgPSBzaW4oLXJvdEFuZ2xlICogMS41KTsKICAgICAgICB2ZWMzIHAgPSBsb2NhbFA7CiAgICAgICAgcC54eiA9IHZlYzIoYyAqIGxvY2FsUC54IC0gcyAqIGxvY2FsUC56LCBzICogbG9jYWxQLnggKyBjICogbG9jYWxQLnopOwogICAgICAgIHAueiArPSBzaW4oYW5pbVRpbWUgKiAzLjApICogMC4zOwogICAgICAgIGlmIChpc0dyb3VuZExldmVsICYmIGFsbG93QW5pbWF0aW9uKSB7CiAgICAgICAgICAgIHBpZWNlID0gaG9yc2VNb2RlbChwKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwaWVjZSA9IGtuaWdodChwKTsKICAgICAgICB9CiAgICB9IGVsc2UgaWYgKHBpZWNlVHlwZSA8IDAuNjkpIHsKICAgICAgICBmbG9hdCBjID0gY29zKC1yb3RBbmdsZSAqIDAuOCksIHMgPSBzaW4oLXJvdEFuZ2xlICogMC44KTsKICAgICAgICB2ZWMzIHAgPSBsb2NhbFA7CiAgICAgICAgcC54eiA9IHZlYzIoYyAqIGxvY2FsUC54IC0gcyAqIGxvY2FsUC56LCBzICogbG9jYWxQLnggKyBjICogbG9jYWxQLnopOwogICAgICAgIHAueiArPSBzaW4oYW5pbVRpbWUgKiAyLjApICogMC4zNTsKICAgICAgICBwaWVjZSA9IGJpc2hvcChwKTsKICAgIH0gZWxzZSBpZiAocGllY2VUeXBlIDwgMC44NSkgewogICAgICAgIGZsb2F0IGMgPSBjb3MoLXJvdEFuZ2xlICogMS4yKSwgcyA9IHNpbigtcm90QW5nbGUgKiAxLjIpOwogICAgICAgIHZlYzMgcCA9IGxvY2FsUDsKICAgICAgICBwLnh6ID0gdmVjMihjICogbG9jYWxQLnggLSBzICogbG9jYWxQLnosIHMgKiBsb2NhbFAueCArIGMgKiBsb2NhbFAueik7CiAgICAgICAgZmxvYXQgc2NhbGUgPSAxLjAgKyBzaW4oYW5pbVRpbWUgKiAyLjUpICogMC4wNTsKICAgICAgICBwICo9IHNjYWxlOwogICAgICAgIHBpZWNlID0gcXVlZW4ocCkgLyBzY2FsZTsKICAgIH0gZWxzZSB7CiAgICAgICAgZmxvYXQgYyA9IGNvcygtcm90QW5nbGUgKiAyLjApLCBzID0gc2luKC1yb3RBbmdsZSAqIDIuMCk7CiAgICAgICAgdmVjMyBwID0gbG9jYWxQOwogICAgICAgIHAueHogPSB2ZWMyKGMgKiBsb2NhbFAueCAtIHMgKiBsb2NhbFAueiwgcyAqIGxvY2FsUC54ICsgYyAqIGxvY2FsUC56KTsKICAgICAgICBwaWVjZSA9IGtpbmcocCk7CiAgICB9CiAgICByZXR1cm4gcGllY2U7Cn0KZmxvYXQgdGlsZVNoYXBlKHZlYzMgcG9zaXRpb24pIHsKICAgICB2ZWMyIHRpbGVMb2NhbCA9IG1vZChwb3NpdGlvbi54eiwgMS4wKSAtIHZlYzIoMC41KTsKICAgICB2ZWMzIGJveFBvcyA9IHZlYzModGlsZUxvY2FsLngsIHBvc2l0aW9uLnksIHRpbGVMb2NhbC55KTsKICAgICByZXR1cm4gcm91bmRCb3goYm94UG9zLCB2ZWMzKDAuNDY4KSwgMC4wMjEpOwp9CmZsb2F0IHNjZW5lRGlzdGFuY2UodmVjMyBwb3NpdGlvbikgewogICAgIGZsb2F0IGZsb29yVGlsZXMgPSB0aWxlU2hhcGUocG9zaXRpb24pOwogICAgIGZsb2F0IGNoZXNzUGllY2VzID0gY2hlc3NGaWVsZChwb3NpdGlvbik7CiAgICAgcmV0dXJuIG1pbihmbG9vclRpbGVzLCBjaGVzc1BpZWNlcyk7Cn0KZmxvYXQgdHJhY2UodmVjMyBybywgdmVjMyByZCkgewogICAgZmxvYXQgdCA9IDAuMDsKICAgIGZvcihpbnQgaSA9IDA7IGkgPCAxMjA7IGkrKykgewogICAgICAgIGlmIChpID4gODAgJiYgdCA+IDgwLjApIGJyZWFrOwogICAgICAgIHZlYzMgcCA9IHJvICsgcmQgKiB0OwogICAgICAgIGZsb2F0IGRpc3QgPSBzY2VuZURpc3RhbmNlKHApOwogICAgICAgIGZsb2F0IGRpc3RGcm9tQ2FtZXJhID0gbGVuZ3RoKHAgLSBybyk7CiAgICAgICAgdmVjMyBjZWxsSWQgPSBmbG9vcihwIC8gMTAuMCk7CiAgICAgICAgYm9vbCBpc0Zsb2F0aW5nID0gKGNlbGxJZC55ID4gMC4wKTsKICAgICAgICBmbG9hdCB0aHJlc2hvbGQ7CiAgICAgICAgaWYgKGRpc3RGcm9tQ2FtZXJhIDwgMTUuMCkgewogICAgICAgICAgICB0aHJlc2hvbGQgPSBpc0Zsb2F0aW5nID8gMC4wMDIgOiAwLjAwMDU7CiAgICAgICAgfSBlbHNlIGlmIChkaXN0RnJvbUNhbWVyYSA8IDMwLjApIHsKICAgICAgICAgICAgdGhyZXNob2xkID0gaXNGbG9hdGluZyA/IDAuMDA2IDogMC4wMDI7CiAgICAgICAgfSBlbHNlIGlmIChkaXN0RnJvbUNhbWVyYSA8IDYwLjApIHsKICAgICAgICAgICAgdGhyZXNob2xkID0gaXNGbG9hdGluZyA/IDAuMDEyIDogMC4wMDU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyZXNob2xkID0gMC4wMTU7CiAgICAgICAgfQogICAgICAgIGlmKGRpc3QgPCB0aHJlc2hvbGQgfHwgdCA+IDEyMC4wKSBicmVhazsKICAgICAgICBmbG9hdCBzdGVwU2l6ZTsKICAgICAgICBpZiAoZGlzdEZyb21DYW1lcmEgPCAyMC4wKSB7CiAgICAgICAgICAgIHN0ZXBTaXplID0gMC41OwogICAgICAgIH0gZWxzZSBpZiAoZGlzdEZyb21DYW1lcmEgPCA1MC4wKSB7CiAgICAgICAgICAgIHN0ZXBTaXplID0gMC42NTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzdGVwU2l6ZSA9IDAuODU7CiAgICAgICAgfQogICAgICAgIHQgKz0gZGlzdCAqIHN0ZXBTaXplOwogICAgfQogICAgcmV0dXJuIHQ7Cn0KdmVjMyBub3JtYWwodmVjMyBzcCkgewogICAgZmxvYXQgZGlzdEZyb21DYW1lcmEgPSBsZW5ndGgoc3AgLSB1Q2FtZXJhUG9zKTsKICAgIHZlYzMgaWQgPSBmbG9vcihzcCAvIDEwLjApOwogICAgYm9vbCBpc0Zsb2F0aW5nID0gKGlkLnkgPiAwLjApOwogICAgZmxvYXQgZXBzaWxvbjsKICAgIGlmIChpc0Zsb2F0aW5nKSB7CiAgICAgICAgZXBzaWxvbiA9IDAuMDA0OwogICAgfSBlbHNlIHsKICAgICAgICBpZiAoZGlzdEZyb21DYW1lcmEgPCAyMC4wKSB7CiAgICAgICAgICAgIGVwc2lsb24gPSAwLjAwMDM7CiAgICAgICAgfSBlbHNlIGlmIChkaXN0RnJvbUNhbWVyYSA8IDQwLjApIHsKICAgICAgICAgICAgZXBzaWxvbiA9IDAuMDAxNTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlcHNpbG9uID0gMC4wMDM7CiAgICAgICAgfQogICAgfQogICAgdmVjMiBlID0gdmVjMihlcHNpbG9uLCAwLjApOwogICAgcmV0dXJuIG5vcm1hbGl6ZSh2ZWMzKAogICAgICAgIHNjZW5lRGlzdGFuY2Uoc3AgKyBlLnh5eSkgLSBzY2VuZURpc3RhbmNlKHNwIC0gZS54eXkpLAogICAgICAgIHNjZW5lRGlzdGFuY2Uoc3AgKyBlLnl4eSkgLSBzY2VuZURpc3RhbmNlKHNwIC0gZS55eHkpLAogICAgICAgIHNjZW5lRGlzdGFuY2Uoc3AgKyBlLnl5eCkgLSBzY2VuZURpc3RhbmNlKHNwIC0gZS55eXgpCiAgICApKTsKfQpmbG9hdCBjYWxjdWxhdGVBTyh2ZWMzIHBvcywgdmVjMyBub3IpIHsKICAgIGZsb2F0IHNjYSA9IDIuMCwgb2NjID0gMC4wOwogICAgZmxvYXQgZGlzdEZyb21DYW1lcmEgPSBsZW5ndGgocG9zIC0gdUNhbWVyYVBvcyk7CiAgICBmbG9hdCBzdGVwQmFzZSA9IGRpc3RGcm9tQ2FtZXJhIDwgMjAuMCA/IDAuMDMgOiAwLjA2OwogICAgZm9yKGludCBpID0gMDsgaSA8IDM7IGkrKykgewogICAgICAgIGZsb2F0IGhyID0gc3RlcEJhc2UgKyBmbG9hdChpKSAqIDAuMTU7CiAgICAgICAgZmxvYXQgZGQgPSBzY2VuZURpc3RhbmNlKG5vciAqIGhyICsgcG9zKTsKICAgICAgICBvY2MgKz0gKGhyIC0gZGQpICogc2NhOwogICAgICAgIHNjYSAqPSAwLjc7CiAgICB9CiAgICBmbG9hdCBhb1Jlc3VsdCA9IGNsYW1wKDEuMCAtIG9jYyAqIDAuOCwgMC4wLCAxLjApOwogICAgcmV0dXJuIG1heChhb1Jlc3VsdCwgMC42KTsKfQp2ZWMzIGxpZ2h0aW5nKHZlYzMgc3AsIHZlYzMgc24sIHZlYzMgbHAsIHZlYzMgcmQpIHsKICAgIGZsb2F0IGRpc3RGcm9tQ2FtZXJhID0gbGVuZ3RoKHNwIC0gdUNhbWVyYVBvcyk7CiAgICB2ZWMzIGx2ID0gbHAgLSBzcDsKICAgIGZsb2F0IGxkaXN0ID0gbWF4KGxlbmd0aChsdiksIDAuMDAxKTsKICAgIHZlYzMgbGRpciA9IGx2IC8gbGRpc3Q7CiAgICBmbG9hdCBhdHRlID0gMS4wIC8gKDEuMCArIDAuMDAyICogbGRpc3QgKiBsZGlzdCk7CiAgICBmbG9hdCBkaWZmID0gbWF4KGRvdChsZGlyLCBzbiksIDAuMCk7CiAgICB2ZWMzIGlkID0gZmxvb3Ioc3AgLyAxMC4wKTsKICAgIHZlYzMgbG9jYWxQID0gbW9kKHNwLCAxMC4wKSAtIDUuMDsKICAgIGZsb2F0IHJhbmRWYWwgPSBybmQoaWQueHogKyB2ZWMyKGlkLnkgKiAxMC4wKSk7CiAgICBmbG9hdCBwaWVjZVR5cGUgPSBmcmFjdChyYW5kVmFsICogNi4wKTsKICAgIGJvb2wgaXNDbG9ja1NwaGVyZSA9IChwaWVjZVR5cGUgPCAwLjE1KTsKICAgIGZsb2F0IHNwZWNQb3dlciA9IGlzQ2xvY2tTcGhlcmUgPyAxMjAuMCA6IDEwLjA7CiAgICBmbG9hdCBzcGVjID0gcG93KG1heChkb3QocmVmbGVjdCgtbGRpciwgc24pLCAtcmQpLCAwLjApLCBzcGVjUG93ZXIpICogKGlzQ2xvY2tTcGhlcmUgPyAxLjAgOiAxLjApOwogICAgZmxvYXQgYW8gPSAxLjA7CiAgICBpZiAoZGlzdEZyb21DYW1lcmEgPCAxOC4wKSB7IC8vIDIwJ2RlbiAxOCdlCiAgICAgICAgYW8gPSBjYWxjdWxhdGVBTyhzcCwgc24pOwogICAgfQogICAgdmVjMiBncmlkQ29vcmQgPSBmbG9vcihzcC54eik7CiAgICBmbG9hdCBwYXR0ZXJuVmFsdWUgPSBtb2QoZ3JpZENvb3JkLnggKyBncmlkQ29vcmQueSwgMi4wKTsKICAgIHZlYzMgZGFya0dyYXkgPSB2ZWMzKDAuMDUpOwogICAgdmVjMyBsaWdodEdyYXkgPSB2ZWMzKDAuMzUpOwogICAgdmVjMyB0aWxlQ29sb3IgPSBtaXgoZGFya0dyYXksIGxpZ2h0R3JheSwgcGF0dGVyblZhbHVlKTsKICAgIGJvb2wgaXNDaGFpbkNlbGwgPSAocGllY2VUeXBlID49IDAuMTUgJiYgcGllY2VUeXBlIDwgMC4yNCk7CiAgICBmbG9hdCBjaGVzc1BpZWNlUGF0dGVybiA9IG1vZChmbG9vcihzcC54IC8gMTAuMCkgKyBmbG9vcihzcC56IC8gMTAuMCksIDIuMCk7CiAgICB2ZWMzIGRheUxpZ2h0UGllY2UgPSB2ZWMzKDAuMywgMC4yMiwgMC4wOCk7CiAgICB2ZWMzIGRheURhcmtQaWVjZSA9IHZlYzMoMC4wMiwgMC4wMiwgMC4wMSk7CiAgICB2ZWMzIG5pZ2h0TGlnaHRQaWVjZSA9IHZlYzMoMi4yLCAwLjY1LCAwLjE1KTsKICAgIHZlYzMgbmlnaHREYXJrUGllY2UgPSB2ZWMzKDAuMTUsIDAuNTUsIDEuOCk7CiAgICB2ZWMzIGxpZ2h0UGllY2VDb2xvciA9IGlzRGF5VGltZSA/IGRheUxpZ2h0UGllY2UgOiBuaWdodExpZ2h0UGllY2U7CiAgICB2ZWMzIGRhcmtQaWVjZUNvbG9yID0gaXNEYXlUaW1lID8gZGF5RGFya1BpZWNlIDogbmlnaHREYXJrUGllY2U7CiAgICB2ZWMzIHBpZWNlQ29sb3IgPSBtaXgoZGFya1BpZWNlQ29sb3IsIGxpZ2h0UGllY2VDb2xvciwgY2hlc3NQaWVjZVBhdHRlcm4pOwogICAgaWYgKGlzQ2xvY2tTcGhlcmUpIHsKICAgICAgICB2ZWMzIGNsb2NrUCA9IGxvY2FsUDsKICAgICAgICBjbG9ja1AueSAtPSAxLjI7CiAgICAgICAgZmxvYXQgZGlzdFRvQ2FtID0gbGVuZ3RoKHNwIC0gdUNhbWVyYVBvcyk7CiAgICAgICAgaWYgKGRpc3RUb0NhbSA8IDgwLjApIHsgLy8gU2FkZWNlIMOnb2sgdXpha3RhIGthcGF0CiAgICAgICAgICAgIGZsb2F0IHJvdFNwZWVkID0gKHJhbmRWYWwgKiAyLjAgLSAxLjApICogMS4wOwogICAgICAgICAgICBmbG9hdCBhbmdsZSA9IGlUaW1lICogcm90U3BlZWQ7CiAgICAgICAgICAgIGZsb2F0IGMgPSBjb3MoYW5nbGUpLCBzID0gc2luKGFuZ2xlKTsKICAgICAgICAgICAgY2xvY2tQLnh6ID0gdmVjMihjICogY2xvY2tQLnggLSBzICogY2xvY2tQLnosIHMgKiBjbG9ja1AueCArIGMgKiBjbG9ja1Aueik7CiAgICAgICAgfQogICAgICAgIGZsb2F0IHBhdHRlcm4gPSBnZXRDbG9ja1BhdHRlcm4oY2xvY2tQKTsKICAgICAgICBwaWVjZUNvbG9yID0gdmVjMygwLjA1KTsKICAgIH0KICAgIGlmIChpc0NoYWluQ2VsbCAmJiAhaXNDbG9ja1NwaGVyZSkgewogICAgICAgIHBpZWNlQ29sb3IgPSB2ZWMzKDAuMDUpOwogICAgfQogICAgZmxvYXQgaXNQaWVjZSA9IHN0ZXAoYWJzKGNoZXNzRmllbGQoc3ApKSwgMC41KTsKICAgIHZlYzMgYWxiZWRvID0gbWl4KHRpbGVDb2xvciwgcGllY2VDb2xvciwgaXNQaWVjZSk7CiAgICBib29sIGlzT3JhbmdlUGllY2UgPSAoaXNQaWVjZSA+IDAuNSAmJiBjaGVzc1BpZWNlUGF0dGVybiA+IDAuNSAmJiAhaXNDbG9ja1NwaGVyZSAmJiAhaXNDaGFpbkNlbGwpOwogICAgdmVjMyBzcGVjQ29sb3I7CiAgICBpZiAoaXNDaGFpbkNlbGwgfHwgaXNDbG9ja1NwaGVyZSkgewogICAgICAgIHNwZWNDb2xvciA9IHZlYzMoMC4zKTsKICAgIH0gZWxzZSBpZiAoaXNEYXlUaW1lKSB7CiAgICAgICAgc3BlY0NvbG9yID0gdmVjMygwLjksIDAuNSwgMC4yKTsKICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKGlzT3JhbmdlUGllY2UpIHsKICAgICAgICAgICAgc3BlY0NvbG9yID0gdmVjMygyLjUsIDAuOCwgMC4zKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzcGVjQ29sb3IgPSB2ZWMzKDAuNCwgMS4yLCAyLjgpOwogICAgICAgIH0KICAgIH0KICAgIHZlYzMgY29sb3IgPSAoZGlmZiAqIGFsYmVkbyArIHNwZWMgKiBzcGVjQ29sb3IpICogYXR0ZTsKICAgIHJldHVybiBjb2xvciAqIGFvOwp9CnZlYzIgcGF0aChmbG9hdCB6KSB7CiAgICBmbG9hdCBzID0gc2luKHogLyAzNi4wKSAqIGNvcyh6IC8gMTguMCk7CiAgICByZXR1cm4gdmVjMihzICogMTYuMCwgMC4wKTsKfQp2b2lkIG1haW4oKSB7CiAgICB2ZWMyIGZyYWdDb29yZCA9IGdsX0ZyYWdDb29yZC54eTsKICAgIHZlYzIgdXYgPSAoZnJhZ0Nvb3JkIC0gaVJlc29sdXRpb24ueHkgKiAwLjUpIC8gaVJlc29sdXRpb24ueTsKICAgIHV2ID0gbm9ybWFsaXplKHV2KSAqIHRhbihhc2luKGxlbmd0aCh1dikgKiAxLjApKTsKICAgIHZlYzMgcm8gPSB1Q2FtZXJhUG9zOwogICAgdmVjMyBsayA9IHVDYW1lcmFUYXJnZXQ7CiAgICB2ZWMzIGxwID0gcm8gKyB2ZWMzKDAuMCwgNS4wLCAwLjApOwogICAgZmxvYXQgRk9WID0gMS41NzsKICAgIHZlYzMgZndkID0gbm9ybWFsaXplKGxrIC0gcm8pOwogICAgdmVjMyByZ3QgPSBub3JtYWxpemUodmVjMyhmd2QueiwgMC4wLCAtZndkLngpKTsKICAgIHZlYzMgdXAgPSBjcm9zcyhmd2QsIHJndCk7CiAgICB2ZWMzIHJkID0gbm9ybWFsaXplKGZ3ZCArIEZPViAqIHV2LnggKiByZ3QgKyBGT1YgKiB1di55ICogdXApOwogICAgZmxvYXQgdCA9IHRyYWNlKHJvLCByZCk7CiAgICBmbG9hdCBmYXIgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCB0IC8gMTIwLjApOwogICAgdmVjMyBzcCA9IHJvICsgcmQgKiB0OwogICAgdmVjMyBzbiA9IG5vcm1hbChzcCk7CiAgICB2ZWMzIGNvbG9yID0gbGlnaHRpbmcoc3AsIHNuLCBscCwgcmQpOwogICAgZmxvYXQgZGlzdEZyb21DYW1lcmEgPSBsZW5ndGgoc3AgLSBybyk7CiAgICB2ZWMzIHJlZlJheSA9IHJlZmxlY3QocmQsIHNuKTsKICAgIGZsb2F0IGJpYXMgPSBkaXN0RnJvbUNhbWVyYSA8IDIwLjAgPyAwLjAzIDogMC4wNjsKICAgIGZsb2F0IHQyID0gdHJhY2Uoc3AgKyBzbiAqIGJpYXMsIHJlZlJheSk7CiAgICB2ZWMzIHJzcCA9IHNwICsgc24gKiBiaWFzICsgcmVmUmF5ICogdDI7CiAgICB2ZWMzIHJzbiA9IG5vcm1hbChyc3ApOwogICAgdmVjMyByZWZDb2xvciA9IGxpZ2h0aW5nKHJzcCwgcnNuLCBscCwgcmVmUmF5KTsKICAgIGZsb2F0IHJlZlN0cmVuZ3RoOwogICAgaWYgKGRpc3RGcm9tQ2FtZXJhIDwgMjAuMCkgewogICAgICAgIHJlZlN0cmVuZ3RoID0gMC42OwogICAgfSBlbHNlIGlmIChkaXN0RnJvbUNhbWVyYSA8IDM1LjApIHsKICAgICAgICByZWZTdHJlbmd0aCA9IDAuNTsKICAgIH0gZWxzZSB7CiAgICAgICAgcmVmU3RyZW5ndGggPSAwLjQ7CiAgICB9CiAgICBjb2xvciArPSByZWZDb2xvciAqIHJlZlN0cmVuZ3RoOwogICAgdmVjMyB0b3BDb2xvciwgdXBwZXJDb2xvciwgbWlkQ29sb3IsIGhvdFBpbmtDb2xvciwgZGVlcFBpbmtDb2xvciwgZGFya1BpbmtDb2xvciwgdmVyeURhcmtDb2xvciwgbmVhckJsYWNrQ29sb3IsIGJsYWNrQ29sb3I7CiAgICBpZiAoaXNEYXlUaW1lKSB7CiAgICAgICAgdG9wQ29sb3IgPSB2ZWMzKDEuMCwgMC42LCAwLjI1KTsKICAgICAgICB1cHBlckNvbG9yID0gdmVjMygxLjIsIDAuNCwgMC4zKTsKICAgICAgICBtaWRDb2xvciA9IHZlYzMoMS4xLCAwLjQ1LCAwLjI4KTsKICAgICAgICBob3RQaW5rQ29sb3IgPSB2ZWMzKDAuOCwgMC4zNSwgMC4yNSk7CiAgICAgICAgZGVlcFBpbmtDb2xvciA9IHZlYzMoMC42LCAwLjI4LCAwLjIwKTsKICAgICAgICBkYXJrUGlua0NvbG9yID0gdmVjMygwLjQ1LCAwLjIyLCAwLjE1KTsKICAgICAgICB2ZXJ5RGFya0NvbG9yID0gdmVjMygwLjM1LCAwLjE4LCAwLjEyKTsKICAgICAgICBuZWFyQmxhY2tDb2xvciA9IHZlYzMoMC4yNSwgMC4xNSwgMC4xMCk7CiAgICAgICAgYmxhY2tDb2xvciA9IHZlYzMoMC4yMCwgMC4xMiwgMC4wOCk7CiAgICB9IGVsc2UgewogICAgICAgIHRvcENvbG9yID0gdmVjMygyLjIsIDAuOSwgMS40KTsKICAgICAgICB1cHBlckNvbG9yID0gdmVjMygyLjQsIDAuNywgMS4yKTsKICAgICAgICBtaWRDb2xvciA9IHZlYzMoMi41LCAwLjU1LCAxLjApOwogICAgICAgIGhvdFBpbmtDb2xvciA9IHZlYzMoMi4yLCAwLjQsIDAuODUpOwogICAgICAgIGRlZXBQaW5rQ29sb3IgPSB2ZWMzKDEuNiwgMC4yNSwgMC42KTsKICAgICAgICBkYXJrUGlua0NvbG9yID0gdmVjMygwLjgsIDAuMTIsIDAuMzUpOwogICAgICAgIHZlcnlEYXJrQ29sb3IgPSB2ZWMzKDAuMiwgMC4wMywgMC4xKTsKICAgICAgICBuZWFyQmxhY2tDb2xvciA9IHZlYzMoMC4wNSwgMC4wLCAwLjAyKTsKICAgICAgICBibGFja0NvbG9yID0gdmVjMygwLjAsIDAuMCwgMC4wKTsKICAgIH0KICAgIGZsb2F0IHkgPSByZC55OwogICAgdmVjMyBza3lHcmFkaWVudDsKICAgIGlmICh5ID4gMC43NSkgewogICAgICAgIGZsb2F0IGJsZW5kID0gc21vb3Roc3RlcCgwLjc1LCAxLjAsIHkpOwogICAgICAgIHNreUdyYWRpZW50ID0gbWl4KHVwcGVyQ29sb3IsIHRvcENvbG9yLCBibGVuZCk7CiAgICB9IGVsc2UgaWYgKHkgPiAwLjU1KSB7CiAgICAgICAgZmxvYXQgYmxlbmQgPSBzbW9vdGhzdGVwKDAuNTUsIDAuNzUsIHkpOwogICAgICAgIHNreUdyYWRpZW50ID0gbWl4KG1pZENvbG9yLCB1cHBlckNvbG9yLCBibGVuZCk7CiAgICB9IGVsc2UgaWYgKHkgPiAwLjQpIHsKICAgICAgICBmbG9hdCBibGVuZCA9IHNtb290aHN0ZXAoMC40LCAwLjU1LCB5KTsKICAgICAgICBza3lHcmFkaWVudCA9IG1peChob3RQaW5rQ29sb3IsIG1pZENvbG9yLCBibGVuZCk7CiAgICB9IGVsc2UgaWYgKHkgPiAwLjI1KSB7CiAgICAgICAgZmxvYXQgYmxlbmQgPSBzbW9vdGhzdGVwKDAuMjUsIDAuNCwgeSk7CiAgICAgICAgc2t5R3JhZGllbnQgPSBtaXgoZGVlcFBpbmtDb2xvciwgaG90UGlua0NvbG9yLCBibGVuZCk7CiAgICB9IGVsc2UgaWYgKHkgPiAwLjEpIHsKICAgICAgICBmbG9hdCBibGVuZCA9IHNtb290aHN0ZXAoMC4xLCAwLjI1LCB5KTsKICAgICAgICBza3lHcmFkaWVudCA9IG1peChkYXJrUGlua0NvbG9yLCBkZWVwUGlua0NvbG9yLCBibGVuZCk7CiAgICB9IGVsc2UgaWYgKHkgPiAtMC4wNSkgewogICAgICAgIGZsb2F0IGJsZW5kID0gc21vb3Roc3RlcCgtMC4wNSwgMC4xLCB5KTsKICAgICAgICBza3lHcmFkaWVudCA9IG1peCh2ZXJ5RGFya0NvbG9yLCBkYXJrUGlua0NvbG9yLCBibGVuZCk7CiAgICB9IGVsc2UgaWYgKHkgPiAtMC4yKSB7CiAgICAgICAgZmxvYXQgYmxlbmQgPSBzbW9vdGhzdGVwKC0wLjIsIC0wLjA1LCB5KTsKICAgICAgICBza3lHcmFkaWVudCA9IG1peChuZWFyQmxhY2tDb2xvciwgdmVyeURhcmtDb2xvciwgYmxlbmQpOwogICAgfSBlbHNlIHsKICAgICAgICBmbG9hdCBibGVuZCA9IHNtb290aHN0ZXAoLTAuNCwgLTAuMiwgeSk7CiAgICAgICAgc2t5R3JhZGllbnQgPSBtaXgoYmxhY2tDb2xvciwgbmVhckJsYWNrQ29sb3IsIGJsZW5kKTsKICAgIH0KICAgIHZlYzMgc2t5ID0gc2t5R3JhZGllbnQgKiAoaXNEYXlUaW1lID8gMy41IDogNC41KSAvIDguMDsKICAgIGNvbG9yID0gbWl4KGNvbG9yLCBza3ksIGZhcik7CiAgICBmbG9hdCB2aWcgPSAxLjAgLSBzbW9vdGhzdGVwKDEuMCwgMy41LCBsZW5ndGgodXYpKTsKICAgIGNvbG9yICo9IG1peCgwLjgsIDEuMCwgdmlnKTsKICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7Cn0K");
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
        const iTimeLocation = gl.getUniformLocation(program, 'iTime');
        const isDayTimeLocation = gl.getUniformLocation(program, 'isDayTime');
        const uRabbitPosLocation = gl.getUniformLocation(program, 'uRabbitPos');
        const uRabbitRotLocation = gl.getUniformLocation(program, 'uRabbitRot');
        const uCameraPosLocation = gl.getUniformLocation(program, 'uCameraPos');
        const uCameraTargetLocation = gl.getUniformLocation(program, 'uCameraTarget');
        function _0xebfc() {
            const now = new Date();
            const hour = now.getHours();
            return hour >= 8 && hour < 20;
        }
        function resize() {
            const isDesktop = !isMobile;
            const basePixelRatio = window.devicePixelRatio || 1;
            let targetWidth = window.innerWidth;
            let targetHeight = window.innerHeight;
            if (isDesktop) {
                const maxWidth = 2560;
                const maxHeight = 1440;
                if (targetWidth > maxWidth || targetHeight > maxHeight) {
                    const scale = Math.min(maxWidth / targetWidth, maxHeight / targetHeight);
                    targetWidth = Math.floor(targetWidth * scale);
                    targetHeight = Math.floor(targetHeight * scale);
                }
            }
            const pixelRatio = isDesktop
                ? Math.min(basePixelRatio, 1.25)
                : Math.min(basePixelRatio, 1.5);
            canvas.width = targetWidth * pixelRatio;
            canvas.height = targetHeight * pixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
            console.log(` Canvas: ${canvas.width}x${canvas.height} (Ratio: ${pixelRatio.toFixed(2)})`);
        }
        resize();
        const threeCanvas = document.getElementById('threeCanvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: threeCanvas,
            alpha: true,
            antialias: true,
            powerPreference: "high-performance",
            precision: "highp",
            stencil: false,
            depth: true,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            failIfMajorPerformanceCaveat: false // GPU yoksa bile çalış!
        });
        const isDesktop = !isMobile;
        let renderWidth = window.innerWidth;
        let renderHeight = window.innerHeight;
        if (isDesktop) {
            const maxWidth = 2560;
            const maxHeight = 1440;
            if (renderWidth > maxWidth || renderHeight > maxHeight) {
                const scale = Math.min(maxWidth / renderWidth, maxHeight / renderHeight);
                renderWidth = Math.floor(renderWidth * scale);
                renderHeight = Math.floor(renderHeight * scale);
                console.log(`️ DESKTOP: Çözünürlük optimize edildi: ${renderWidth}x${renderHeight}`);
            }
        }
        renderer.setSize(renderWidth, renderHeight);
        const pixelRatio = isDesktop
            ? Math.min(window.devicePixelRatio, 1.25)
            : Math.min(window.devicePixelRatio, 1.5);
        renderer.setPixelRatio(pixelRatio);
        console.log(` PixelRatio: ${pixelRatio.toFixed(2)} (${isDesktop ? 'Desktop' : 'Mobile'})`);
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        scene.add(dirLight);
        const backLight = new THREE.DirectionalLight(0xffaa66, 0.8);
        backLight.position.set(-5, 5, -5);
        scene.add(backLight);
        const fillLight = new THREE.DirectionalLight(0xaaddff, 0.6);
        fillLight.position.set(0, 5, -10);
        scene.add(fillLight);
        let rabbitModel = null;
        let rabbitMixer = null;
        const loader = new THREE.GLTFLoader();
        loader.load(
            'https://busrasuhaydar.github.io/rabbit/rabbit.glb',
            function(gltf) {
                rabbitModel = gltf.scene;
                rabbitModel.scale.set(0.16, 0.16, 0.16);
                rabbitModel.position.set(rabbit.position.x, rabbit.position.y, rabbit.position.z);
                rabbitModel.rotation.y = 0;
                rabbitModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.metalness = 0.7;
                            child.material.roughness = 0.3;
                            child.material.needsUpdate = true;
                            if (child.material.map) {
                                child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                child.material.map.minFilter = THREE.LinearMipMapLinearFilter;
                                child.material.map.magFilter = THREE.LinearFilter;
                            }
                        }
                        child.material.color.multiplyScalar(1.5);
                        child.material.needsUpdate = true;
                    }
                });
                scene.add(rabbitModel);
                let earLeftBone = null;
                let earRightBone = null;
                console.log(' Searching for ear bones...');
                rabbitModel.traverse((child) => {
                    if (child.name) {
                        const nameLower = child.name.toLowerCase();
                        console.log('Found bone/object:', child.name, '- Type:', child.type);
                        if (nameLower.includes('ear') || nameLower.includes('kulak') ||
                            nameLower.includes('oreille') || nameLower.includes('ohr')) {
                            if (nameLower.includes('left') || nameLower.includes('sol') ||
                                nameLower.includes('l.') || nameLower.includes('.l') ||
                                nameLower.includes('gauche')) {
                                earLeftBone = child;
                                console.log(' SOL KULAK BULUNDU:', child.name);
                            }
                            else if (nameLower.includes('right') || nameLower.includes('sag') ||
                                     nameLower.includes('r.') || nameLower.includes('.r') ||
                                     nameLower.includes('droite')) {
                                earRightBone = child;
                                console.log(' SAĞ KULAK BULUNDU:', child.name);
                            }
                        }
                    }
                });
                rabbit.earLeftBone = earLeftBone;
                rabbit.earRightBone = earRightBone;
                rabbit.earTime = 0;
                if (earLeftBone && earRightBone) {
                    console.log(' HER İKİ KULAK DA HAZIR!');
                } else {
                    console.warn('️ KULAKLAR BULUNAMADI!', 'Sol:', earLeftBone?.name, 'Sağ:', earRightBone?.name);
                }
                if (gltf.animations && gltf.animations.length > 0) {
                    rabbitMixer = new THREE.AnimationMixer(rabbitModel);
                    const action = rabbitMixer.clipAction(gltf.animations[0]);
                    action.setDuration(gltf.animations[0].duration * 0.4);
                    action.play();
                }
                console.log('Rabbit loaded!');
            },
            function(xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function(error) {
                console.error('Error loading rabbit:', error);
            }
        );
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const isDesktop = !isMobile;
                let targetWidth = window.innerWidth;
                let targetHeight = window.innerHeight;
                if (isDesktop) {
                    const maxWidth = 2560;
                    const maxHeight = 1440;
                    if (targetWidth > maxWidth || targetHeight > maxHeight) {
                        const scale = Math.min(maxWidth / targetWidth, maxHeight / targetHeight);
                        targetWidth = Math.floor(targetWidth * scale);
                        targetHeight = Math.floor(targetHeight * scale);
                    }
                }
                camera.aspect = targetWidth / targetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(targetWidth, targetHeight);
                resize();
            }, 150);
        });
        let lastTime = Date.now();
        function checkCollision(newX, newZ) {
            const pieceX = Math.floor(newX / 10.0);
            const pieceZ = Math.floor(newZ / 10.0);
            const pieceCenterX = pieceX * 10.0;
            const pieceCenterZ = pieceZ * 10.0;
            const dist = Math.sqrt(
                Math.pow(newX - pieceCenterX, 2) +
                Math.pow(newZ - pieceCenterZ, 2)
            );
            return dist < 2.0;
        }
        function render() {
            const currentTime = Date.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            const time = (currentTime - startTime) / 1000;
            let forward = 0;
            let turnInput = 0;
            if (cinematicMode) {
                cinematicTime += deltaTime * 0.65;
                const totalCycle = 300.0;
                const t = cinematicTime % totalCycle;
                function _0xc9da(progress, duration) {
                    const p = Math.min(progress / duration, 1.0);
                    return p * p * (3.0 - 2.0 * p);
                }
                let cameraAngle, cameraDist, cameraHeight, rabbitSpeed;
                let targetY = 2;
                const rabbitPathRadius = 28;
                if (t < 50.0) {
                    const localT = t;
                    const transBlend = _0xc9da(localT, 12.0);
                    cameraAngle = cinematicTime * 0.12 + transBlend * Math.PI * 0.3;
                    cameraDist = 14 + transBlend * 6;
                    cameraHeight = 6 + transBlend * 4;
                    rabbitSpeed = 0.38;
                    targetY = 2 + Math.sin(cinematicTime * 0.4) * 1.2;
                } else if (t < 100.0) {
                    const localT = t - 50.0;
                    const transBlend = _0xc9da(localT, 12.0);
                    cameraAngle = Math.PI * 0.3 + cinematicTime * 0.08 + transBlend * Math.PI * 0.4;
                    cameraDist = 20 + transBlend * -5;
                    cameraHeight = 10 + Math.sin(cinematicTime * 0.3) * 3 + transBlend * -3;
                    rabbitSpeed = 0.42;
                    targetY = 2.5 + Math.sin(cinematicTime * 0.5) * 1.5;
                } else if (t < 150.0) {
                    const localT = t - 100.0;
                    const transBlend = _0xc9da(localT, 12.0);
                    cameraAngle = Math.PI * 0.7 + cinematicTime * 0.15 + transBlend * Math.PI * 0.5;
                    cameraDist = 15 + transBlend * -3;
                    cameraHeight = 7 + transBlend * -2;
                    rabbitSpeed = 0.36;
                    targetY = 2.2 + Math.sin(cinematicTime * 0.6) * 1.0;
                } else if (t < 200.0) {
                    const localT = t - 150.0;
                    const transBlend = _0xc9da(localT, 12.0);
                    cameraAngle = Math.PI * 1.2 + cinematicTime * 0.18 + transBlend * Math.PI * 0.3;
                    cameraDist = 12 + transBlend * 6;
                    cameraHeight = 5 + transBlend * 7;
                    rabbitSpeed = 0.40;
                    targetY = 2 + Math.sin(cinematicTime * 0.45) * 1.3;
                } else if (t < 230.0) {
                    const diveT = t - 200.0;
                    if (diveT < 15.0) {
                        const descendProgress = diveT / 15.0;
                        const smoothDescend = descendProgress * descendProgress * descendProgress;
                        targetY = 2 - smoothDescend * 18.0;
                        cameraAngle = Math.PI * 1.5 + cinematicTime * 0.1;
                        cameraDist = 18 - smoothDescend * 5;
                        cameraHeight = 12 - smoothDescend * 25;
                        rabbitSpeed = 0.25;
                    } else {
                        targetY = -16.0;
                        const exploreT = diveT - 15.0;
                        const wiggleX = Math.sin(exploreT * 1.5) * 5.0;
                        const wiggleZ = Math.cos(exploreT * 1.2) * 4.0;
                        cameraAngle = Math.PI * 1.6 + exploreT * 0.3;
                        cameraDist = 13;
                        cameraHeight = -18;
                        rabbitSpeed = 0.15;
                    }
                } else if (t < 260.0) {
                    const riseT = t - 230.0;
                    const riseDuration = 30.0;
                    const riseProgress = riseT / riseDuration;
                    const smoothRise = 1.0 - Math.pow(1.0 - riseProgress, 2.0);
                    targetY = -16.0 + smoothRise * 18.0;
                    cameraAngle = Math.PI * 1.9 + cinematicTime * 0.12;
                    cameraDist = 13 + smoothRise * 5;
                    cameraHeight = -18 + smoothRise * 30;
                    rabbitSpeed = 0.32 + smoothRise * 0.08;
                } else {
                    const returnT = t - 260.0;
                    const returnBlend = _0xc9da(returnT, 12.0);
                    targetY = 2 + Math.sin(cinematicTime * 0.5) * 0.8;
                    cameraAngle = cinematicTime * 0.1;
                    cameraDist = 18 - returnBlend * 4;
                    cameraHeight = 12 - returnBlend * 6;
                    rabbitSpeed = 0.40;
                }
                const rabbitMoveDir = cinematicTime * rabbitSpeed;
                const targetX = Math.cos(rabbitMoveDir) * rabbitPathRadius;
                const targetZ = Math.sin(rabbitMoveDir) * rabbitPathRadius;
                if (!rabbit.smoothX) rabbit.smoothX = targetX;
                if (!rabbit.smoothZ) rabbit.smoothZ = targetZ;
                rabbit.smoothX += (targetX - rabbit.smoothX) * 0.1;
                rabbit.smoothZ += (targetZ - rabbit.smoothZ) * 0.1;
                rabbit.position.x = rabbit.smoothX;
                rabbit.position.z = rabbit.smoothZ;
                if (!rabbit.smoothY) rabbit.smoothY = 2;
                rabbit.smoothY += (targetY - rabbit.smoothY) * 0.06;
                rabbit.position.y = rabbit.smoothY;
                const lookAhead = 0.18;
                const nextX = Math.cos(rabbitMoveDir + lookAhead) * rabbitPathRadius;
                const nextZ = Math.sin(rabbitMoveDir + lookAhead) * rabbitPathRadius;
                const targetRotation = Math.atan2(nextZ - rabbit.position.z, nextX - rabbit.position.x) + Math.PI / 2;
                if (!rabbit.smoothRotation) rabbit.smoothRotation = targetRotation;
                let rotDiff = targetRotation - rabbit.smoothRotation;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                rabbit.smoothRotation += rotDiff * 0.1;
                rabbit.rotation = rabbit.smoothRotation;
                camera.position.x = rabbit.position.x + Math.cos(cameraAngle) * cameraDist;
                camera.position.z = rabbit.position.z + Math.sin(cameraAngle) * cameraDist;
                camera.position.y = rabbit.position.y + (_0xebfc() ? 2.5 : 8.0);
                camera.lookAt(rabbit.position.x, rabbit.position.y + 1.5, rabbit.position.z);
                const camToRabbit = Math.atan2(
                    rabbit.position.z - camera.position.z,
                    rabbit.position.x - camera.position.x
                );
                cameraYaw = camToRabbit;
                isMoving = true;
            } else {
                isMoving = false;
                if (!rabbit.stepTime) rabbit.stepTime = 0;
                if (!rabbit.stepPhase) rabbit.stepPhase = 0;
                if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                    forward = 1;
                    isMoving = true;
                }
                if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                    forward = -1;
                    isMoving = true;
                }
                if (!rabbit.stepTime) rabbit.stepTime = 0;
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    turnInput = 1.0;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    turnInput = -1.0;
                }
                if (keys['q'] || keys['Q']) rabbit.verticalSpeed = 2.5;
                else if (keys['e'] || keys['E']) rabbit.verticalSpeed = -2.5;
                else rabbit.verticalSpeed = 0;
                rabbit.position.y += rabbit.verticalSpeed * deltaTime;
                const turnSpeed = 2.5;
                rabbit.rotation += turnInput * turnSpeed * deltaTime;
                if (forward !== 0) {
                    rabbit.stepTime += deltaTime * 25.0;
                    const step1 = Math.sin(rabbit.stepTime);
                    const step2 = Math.sin(rabbit.stepTime + Math.PI * 0.5);
                    const step3 = Math.sin(rabbit.stepTime + Math.PI);
                    const step4 = Math.sin(rabbit.stepTime + Math.PI * 1.5);
                    const avgStep = (step1 + step2 + step3 + step4) * 0.25;
                    const normalizedStep = avgStep * 0.5 + 0.5;
                    const stepBounce = Math.sin(rabbit.stepTime * 3.0) * 0.02;
                    rabbit.position.y += stepBounce * Math.abs(forward);
                    const baseSpeed = rabbit.moveSpeed * deltaTime;
                    const speedMod = 0.95 + normalizedStep * 0.1;
                    const moveAmount = forward * baseSpeed * speedMod;
                    rabbit.position.x += Math.sin(rabbit.rotation) * moveAmount;
                    rabbit.position.z += Math.cos(rabbit.rotation) * moveAmount;
                } else {
                    rabbit.stepTime = 0;
                }
            }
            if (rabbitModel) {
                rabbitModel.position.set(rabbit.position.x, rabbit.position.y, rabbit.position.z);
                rabbitModel.rotation.y = rabbit.rotation;
                if (!rabbit.earTime) rabbit.earTime = 0;
                rabbit.earTime += deltaTime * 3.0;
                if (rabbit.earLeftBone && rabbit.earRightBone) {
                    const earOpen = Math.sin(rabbit.earTime) * 0.5 + 0.5;
                    const earSpread = (earOpen * 0.8) - 0.4;
                    const earTilt = Math.sin(rabbit.earTime * 1.3) * 0.3;
                    rabbit.earLeftBone.rotation.z = earSpread;
                    rabbit.earLeftBone.rotation.x = earTilt;
                    rabbit.earLeftBone.rotation.y = earOpen * 0.2;
                    rabbit.earRightBone.rotation.z = -earSpread;
                    rabbit.earRightBone.rotation.x = earTilt;
                    rabbit.earRightBone.rotation.y = -earOpen * 0.2;
                }
                rabbit.jumpCooldown -= deltaTime;
                if (rabbit.jumpCooldown <= 0 && !rabbit.isJumping && !cinematicMode && !isMoving) {
                    rabbit.isJumping = true;
                    rabbit.jumpTime = 0;
                    rabbit.jumpCooldown = rabbit.nextJumpIn;
                    rabbit.nextJumpIn = 90 + Math.random() * 60;
                    console.log(' ZIPLAMA! Bir sonraki zıplama: ' + rabbit.nextJumpIn.toFixed(1) + ' saniye');
                }
                if (rabbit.isJumping) {
                    rabbit.jumpTime += deltaTime * 4.0;
                    if (rabbit.jumpTime < Math.PI) {
                        const jumpHeight = Math.sin(rabbit.jumpTime) * 3.5;
                        rabbit.position.y = jumpHeight;
                    } else {
                        rabbit.isJumping = false;
                        rabbit.jumpTime = 0;
                        rabbit.position.y = 0;
                    }
                }
                if (rabbitMixer) {
                    if (isMoving) {
                        rabbitMixer.timeScale = 6.0;
                        rabbitMixer.update(deltaTime);
                    } else if (rabbit.isJumping) {
                        rabbitMixer.timeScale = 8.0;
                        rabbitMixer.update(deltaTime);
                    } else {
                        rabbitMixer.timeScale = 0;
                    }
                }
            }
            if (!cinematicMode) {
                if (turnInput !== 0) {
                    const targetYaw = rabbit.rotation;
                    let diff = targetYaw - cameraYaw;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                cameraYaw += diff * 0.1 * deltaTime;
            }
            const camAngle = cameraYaw + Math.PI + manualCameraAngle;
            const camX = rabbit.position.x + Math.sin(camAngle) * cameraDistance;
            const camY = rabbit.position.y + (_0xebfc() ? 2.5 : 8.0) + manualCameraPitch * 5;
            const camZ = rabbit.position.z + Math.cos(camAngle) * cameraDistance;
            camera.position.x += (camX - camera.position.x) * 5.0 * deltaTime;
            camera.position.y += (camY - camera.position.y) * 5.0 * deltaTime;
            camera.position.z += (camZ - camera.position.z) * 5.0 * deltaTime;
            camera.lookAt(
                rabbit.position.x,
                rabbit.position.y + 3.5,
                rabbit.position.z
            );
            }
            gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(iTimeLocation, time);
            gl.uniform1i(isDayTimeLocation, _0xebfc() ? 1 : 0);
            gl.uniform3f(uRabbitPosLocation, rabbit.position.x, rabbit.position.y, rabbit.position.z);
            gl.uniform1f(uRabbitRotLocation, rabbit.rotation);
            gl.uniform3f(uCameraPosLocation, camera.position.x, camera.position.y, camera.position.z);
            gl.uniform3f(uCameraTargetLocation, rabbit.position.x, rabbit.position.y + 1.5, rabbit.position.z);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>
